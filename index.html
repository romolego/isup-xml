<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XSD Viewer</title>
<style>
  :root{
    --bg:#ffffff; --fg:#0f1720; --muted:#5a6a7a; --line:#e6e9ee;
    --badge:#f4f6fa; --hover:rgba(15,23,32,.06);
    --shadow:0 1px 2px rgba(0,0,0,.06),0 4px 18px rgba(0,0,0,.05);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", Consolas, "Liberation Mono","Courier New", monospace;
    --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--fg); font:14px/1.45 var(--sans)}
  .container{max-width:1200px; margin:0 auto; padding:16px 16px 80px}

  .loader{display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin:2px 0 10px}
  .file{border:1px dashed #cfd6df; border-radius:8px; padding:6px 10px; background:#fbfcff}
  .btn{border:1px solid #cfd6df; background:#fafbfd; color:#203040; padding:6px 10px; border-radius:8px; cursor:pointer}
  .btn[disabled]{opacity:.55; cursor:not-allowed}
  .btn.primary{background:#eefbf5; border-color:#a9e0c8; color:#0f3b2e}
  .btn.ghost{background:#fff}
  .btn.xs{padding:2px 8px; font-size:12px}
  .btn.tiny{padding:2px 8px; font-size:12px}
  .btn.micro{padding:4px 6px; font-size:11px; line-height:1.05;}
  .btn:active{transform:translateY(1px)}
  .tiny{font-size:12px; color:var(--muted)}

  .status{display:flex; gap:8px; align-items:center; flex-wrap:wrap; border-bottom:1px solid var(--line); padding-bottom:8px; margin-bottom:8px}
  .badge{background:var(--badge); color:#223; border:1px solid #e9edf3; padding:4px 8px; border-radius:999px; font-size:12px}
  .progress-wrap{width:100%; height:3px; background:transparent; position:relative; overflow:hidden; display:none}
  .progress{position:absolute; inset:0 100% 0 0; background:linear-gradient(90deg, #bfe7d8, #6fbba0); animation:load 1.2s linear infinite}
  @keyframes load{0%{inset:0 100% 0 0}50%{inset:0 30% 0 0}100%{inset:0 100% 0 0}}

  details{border:1px solid var(--line); border-radius:10px; padding:8px 10px 10px; background:#fff; position:relative; margin-bottom:12px}
  summary{cursor:pointer; font-weight:600; color:#253446}
  .block-actions{position:absolute; right:10px; top:8px; display:flex; gap:6px; align-items:center}
  .panel-body{margin-top:8px}
  .settings{display:grid; gap:8px}
  .settings-row{display:flex; flex-wrap:wrap; gap:14px; align-items:center}
  .settings-row.punctuated{border-top:1px dashed #ccd3dd; padding-top:8px; margin-top:4px}

  .subsection{margin-bottom:14px}
  .subsection:last-child{margin-bottom:0}
  .subsection-head{display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:10px}
  .subsection-title{font-weight:600; color:#1d2b36}
  .subsection-actions{display:flex; flex-wrap:wrap; align-items:center; gap:6px}
  .inner-sep{border-top:1px dashed var(--line); margin:12px 0}

  .single-row-list{display:flex; flex-direction:column; gap:8px; margin-top:10px; align-items:stretch}
  .single-row-chip{display:flex; align-items:flex-start; gap:8px; padding:8px 10px; border:1px solid #e0e6ef; border-radius:12px; background:#f9fbff; font-size:13px; line-height:1.4; box-shadow:0 1px 2px rgba(0,0,0,.04); width:100%; transition:background-color .12s ease-in-out, border-color .12s ease-in-out;}
  .single-row-chip[data-state="shown"]{background:#ffffff; border-color:#d8e2f0}
  .single-row-chip[data-state="hidden"]{background:#f1f5fb; border-color:#d3dce9}
  .single-row-chip[data-status="missing"]{background:#fff6f6; border-color:#f1c3c3; color:#8d3a3a}
  .single-row-chip-checkbox{flex:0 0 auto; margin-top:3px; accent-color:#0b4f3b}
  .single-row-chip-content{flex:1 1 auto; min-width:0; display:flex; flex-direction:column; gap:2px}
  .single-row-chip-title{white-space:normal; overflow-wrap:break-word; word-wrap:break-word; color:#1f2f3a; font-weight:500}
  .single-row-chip-sub{white-space:normal; overflow-wrap:break-word; word-wrap:break-word; color:#5a6a7a}
  .single-row-chip-marker{border:none; background:transparent; font-size:18px; line-height:1; padding:0 2px 0 0; cursor:pointer; color:#94a3b8; display:inline-flex; align-items:center; justify-content:center; min-width:16px; margin-top:2px}
  .single-row-chip-marker:hover{color:#475569}
  .single-row-chip-marker:focus-visible{outline:2px solid #a7f3d0; border-radius:50%}
  .single-row-chip[data-status="missing"] .single-row-chip-marker{color:#d97706}
  .single-row-note{font-size:12px; color:#7b8794}
  .single-row-orphans{margin-top:12px; border:1px dashed #f1c3c3; border-radius:10px; padding:10px; background:#fff9f9; color:#8d3a3a; font-size:12px; display:flex; flex-direction:column; gap:6px}

  .single-row-orphans h4{margin:0; font-size:13px; font-weight:600}
  .single-row-orphans ul{margin:0; padding-left:0; list-style:none; display:flex; flex-direction:column; gap:6px}
  .single-row-orphans li{margin:0; display:block}

  .flt-menu .mi-info{padding:10px 12px; font-size:13px; border-bottom:1px solid #f2f5f9; color:#1d2b36}
  .flt-menu .mi-info strong{display:block; font-weight:600; color:#16242c; margin-bottom:4px}
  .flt-menu .mi-info .mi-info-meta{font-size:12px; color:#5a6a7a; margin-top:2px}
  .flt-menu .mi-info .mi-info-meta span{display:block}
  .flt-menu .mi-actions{display:flex; gap:6px; padding:8px 10px}
  .flt-menu .mi-actions .btn{flex:1}

  .hint{color:var(--muted)}
  em{font-style:italic; color:#5a6a7a}

  /* метки чекбоксов: серые/жирные */
  label{ color:#5a6a7a; font-weight:400; }
  label:has(input:checked){ color:#0f1720; font-weight:600; }

  .cb-inline{display:inline-flex; align-items:center; gap:6px; white-space:nowrap}
  .sep{ color:#9aa6b2; opacity:.9; user-select:none; }

  .count-badge{
    display:inline-flex; align-items:center; justify-content:center;
    min-width:18px; height:18px; padding:0 6px;
    font-size:11px; line-height:1; border-radius:10px;
    background:#f2f5f9; color:#41566a; border:1px solid #dbe3ec;
    cursor:default; user-select:none; margin-left:6px;
  }
  .count-badge[data-state="hidden"]{ background:#fff2f0; color:#7a2e12; border-color:#ffd9d2}
  .count-badge[data-state="shown"]{ background:#ecfdf5; color:#065f46; border-color:#a7f3d0}

  .disabled-strike{ color:#9aa6b2 !important; text-decoration: line-through; }
  .disabled-strike input{ pointer-events:none }

  .tree-controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:14px 0 10px; justify-content:flex-start}
  .tree-help{display:flex; align-items:center; justify-content:flex-end; margin-top:-6px; margin-bottom:4px; gap:8px;}

  .help{width:18px; height:18px; border-radius:50%; border:1px solid #cfd6df; background:#fff; display:inline-flex; align-items:center; justify-content:center; font-weight:700; color:#2b3f4b; cursor:default; position:relative}
  .help:hover .tip{display:block}
  .tip{display:none; position:absolute; top:22px; right:0; background:#1e2a25; color:#e9fff6; padding:8px 10px; border-radius:8px; box-shadow:var(--shadow); width:max-content; max-width:420px; font-size:12px; z-index:20}

  #toggleCompact{ margin-left:8px; }

  .tree-wrap{border:1px solid var(--line); border-radius:10px; overflow:hidden; background:#fff}
  #treeWrap.compact{max-height:51vh; overflow:auto;}

  .tree{--row-h:28px; position:relative}
  .row{
    display:grid; grid-template-columns:auto 1fr auto; gap:8px; align-items:center;
    padding:2px 10px; min-height:var(--row-h); border-top:1px solid #f3f6fb;
    transition: background-color .12s ease-in-out;
  }
  .row:first-child{border-top:none}
  .row:hover{background:var(--hover); box-shadow:var(--shadow)}
  .row[hidden]{display:none!important}
  .left{display:flex; align-items:center; gap:6px; min-width:220px; position:relative}
  .caret{width:14px; height:14px; display:inline-flex; align-items:center; justify-content:center; font-family:var(--mono); font-size:11px; color:#2a3d47; cursor:pointer; user-select:none; border-radius:4px}
  .caret.empty{opacity:.25; cursor:default}
  .dot{width:9px; height:9px; border-radius:50%; background:#1d1d1d12; border:1px solid #00000014; cursor:pointer; flex:0 0 auto}
  .content{display:flex; gap:8px; align-items:baseline; flex-wrap:wrap}
  .badge-mini{background:#fff7ed; border:1px solid #fed7aa; color:#7c3b02; border-radius:6px; padding:0 6px; font-size:11px}
  .badge-mini.parent-hidden-trigger{cursor:pointer; display:inline-flex; align-items:center; gap:4px}
  .badge-mini.parent-hidden-trigger:focus-visible{outline:2px solid #a7f3d0}
  .badge-override{background:#ecfdf5; border:1px solid #a7f3d0; color:#065f46; border-radius:6px; padding:0 6px; font-size:11px}
  .nameRU{font-weight:600; color:#16242c}
  .nameEN{color:#4a5968}
  .type{font-family:var(--mono); background:#f6f8fb; border:1px solid #e6eaf0; padding:1px 6px; border-radius:6px; color:#203040}
  .req{font-size:11px; padding:0 6px; border-radius:6px; border:1px solid}
  .req.req-required{color:#0b5325; background:#ecfdf5; border-color:#a7f3d0}
  .req.req-optional{color:#41566a; background:#f3f6fb; border-color:#e5eaf2}
  .req.req-conditional{color:#7c3b02; background:#fff7ed; border-color:#fed7aa}

  .actions{display:flex; gap:10px; align-items:center; justify-content:flex-end}
  .actions .sep{margin:0 2px; align-self:stretch; display:flex; align-items:center}

  .copy{display:flex; gap:6px; align-items:center}
  .row-filters{display:inline-flex; gap:6px; align-items:center}
  .fbtn{border:1px solid #d7dee8; background:#fafbfd; color:#2a3d47; padding:4px 6px; border-radius:6px; font-size:11px; line-height:1.05; cursor:pointer; min-width:82px; text-align:center; white-space:normal}
  .fbtn.dim{color:#7c8a99; background:#f7f9fc}
  .fbtn.active{background:#ecfdf5; border-color:#a7f3d0; color:#065f46}
  .fbtn.blocked{background:#fff3f3; border-color:#ffd6d6; color:#9a2b2b; text-decoration:line-through; cursor:not-allowed}
  .fbtn:active{transform:translateY(1px)}

  .flt-menu{position:absolute; z-index:1200; background:#ffffff; border:1px solid #e6e9ee; border-radius:10px; box-shadow:var(--shadow); display:none; min-width:240px; max-width:360px}
  .flt-menu .mi{padding:8px 10px; font-size:13px; cursor:pointer; border-top:1px solid #f2f5f9}
  .flt-menu .mi:first-child{border-top:none}
  .flt-menu .mi:hover{background:#f6faf8}
  .flt-menu .mi[aria-disabled="true"]{color:#95a3b1; cursor:not-allowed; background:#fff}

  .row[aria-selected="true"]{outline:2px solid #96e1c5; outline-offset:-2px; background:#f3fbf7}

  .card{position:fixed; z-index:1000; min-width:340px; max-width:520px; background:#fff; border:1px solid var(--line); border-radius:12px; box-shadow:var(--shadow); padding:10px 12px; display:none}
  .card h4{margin:0 0 8px; font-size:14px}
  .kv{display:grid; grid-template-columns:140px 1fr; gap:6px 10px; font-size:13px}
  .kv .k{color:#5a6775}
  .kv .v code{font-family:var(--mono)}
  .card .actions{display:flex; gap:6px; margin-top:8px}
  .card .type-link{color:#0b4f3b; text-decoration:underline; cursor:pointer}
  .card::after{content:""; position:absolute; width:10px; height:10px; background:#fff; transform:rotate(45deg); border-left:1px solid var(--line); border-top:1px solid var(--line)}

  .toast{position:fixed; left:50%; bottom:18px; transform:translateX(-50%); background:#0f1f17; color:#e9fff6; border-radius:10px; padding:10px 12px; box-shadow:var(--shadow); display:none; z-index:1300}

  dialog{border:none; border-radius:12px; padding:16px; box-shadow:var(--shadow); max-width:980px}
  dialog::backdrop{background:rgba(0,0,0,.2)}
  dialog table{border-collapse:collapse; width:100%; font-size:13px; margin-bottom:10px}
  dialog th, dialog td{border:1px solid #e6e9ee; padding:6px 8px; text-align:left; vertical-align:top}
  dialog th{background:#f7f9fc; font-weight:600}
  dialog .dlg-actions{display:flex; justify-content:flex-end; gap:8px; margin-top:12px}

  .sign-slice{ display:flex; align-items:center; gap:12px; margin:14px 0; padding:10px 12px; border:1px solid #e6e9ee; border-radius:10px; background:#ffffff; flex-wrap:wrap; }
  .sign-slice input[type="text"]{ flex:0 0 220px; max-width:100%; padding:6px 8px; border:1px solid #cfd6df; border-radius:6px; font:13px/1.35 var(--mono); color:#203040; background:#f9fbff; }

  #block-view{margin-bottom:12px;}
</style>
</head>
<body>
<div class="container">

  <div class="loader">
    <input class="file" type="file" id="fileInput" accept=".xsd,.xml" multiple/>
    <button class="btn primary" id="parseBtn" disabled>Загрузить и разобрать XSD</button>
  </div>

  <div class="status" id="statusBar">
    <span class="badge" id="filesBadge">Файлов: 0</span>
    <span class="badge" id="globalsBadge">Глоб. элементов: 0</span>
    <span class="badge" id="typesBadge">Типов: 0</span>
    <span class="badge" id="maxDepthBadge">Максимальная глубина: 0</span>
    <span class="badge" id="rowsBadge">Строк всего: 0</span>
    <button class="btn" id="reportBtn">Отчёт</button>
    <div class="progress-wrap" id="progressWrap"><div class="progress"></div></div>
  </div>

  <details open id="block-view">
    <summary>Настройки отображения</summary>
    <div class="block-actions">
      <button class="btn xs ghost" data-select-all="view">Выделить всё</button>
      <button class="btn xs ghost" data-select-none="view">Снять всё</button>
    </div>
    <div class="panel-body">
      <div class="settings">
        <div class="settings-row">
          <label class="cb-inline"><input type="checkbox" data-view="showRU" checked> Имя</label>
          <label class="cb-inline"><input type="checkbox" data-view="showEN" checked> Код</label>
          <label class="cb-inline"><input type="checkbox" data-view="showL"> Уровень вложенности (L-бейдж)</label>
          <label class="cb-inline"><input type="checkbox" data-view="showType"> Тип данных</label>
          <label class="cb-inline"><input type="checkbox" data-view="showReq"> Обязательность</label>
          <label class="cb-inline"><input type="checkbox" data-view="colorLevels" checked> Цветовая индикация уровней</label>
        </div>
        <div class="settings-row punctuated">
          <span class="hint">Кнопки копирования:</span>
          <label class="cb-inline"><input type="checkbox" data-view="copyRU" checked> Имя</label>
          <label class="cb-inline"><input type="checkbox" data-view="copyPath"> Путь</label>
          <label class="cb-inline"><input type="checkbox" data-view="copyEN" checked> Код</label>
          <span class="sep">|</span>
          <span class="hint">Кнопки фильтрации:</span>
          <label class="cb-inline"><input type="checkbox" data-view="rowFilterDisplay" checked> Отображение</label>
          <label class="cb-inline"><input type="checkbox" data-view="rowFilterExpand"> Разворачивание</label>
        </div>
      </div>
    </div>
  </details>

  <div class="filters">
    <details open id="block-service">
      <summary>Фильтры <u>отображения</u></summary>
      <div class="panel-body">
        <div class="subsection" id="displayBranchSection">
          <div class="subsection-head">
            <div class="subsection-title">Отображение всей ветки</div>
            <div class="subsection-actions">
              <button class="btn xs ghost" data-select-all="service">Выделить всё</button>
              <button class="btn xs ghost" data-select-none="service">Снять всё</button>
              <button class="btn xs" id="cfgServiceBtn">Настроить фильтры отображения</button>
              <span class="help" aria-label="Подсказка">?
                <span class="tip">Участвуют только узлы с точно совпадающим кодом (nameEN). Потомки не наследуют участие автоматически.</span>
              </span>
            </div>
          </div>
          <div class="settings-row" id="serviceKeysRow" style="margin-top:6px"></div>
        </div>

        <div class="inner-sep"></div>

        <div class="subsection" id="displaySingleSection">
          <div class="subsection-head">
            <div class="subsection-title">Отображение одной строки</div>
            <div class="subsection-actions">
              <button class="btn xs ghost" data-select-all="service-single">Выделить всё</button>
              <button class="btn xs ghost" data-select-none="service-single">Снять всё</button>
              <button class="btn xs" id="cfgServiceSingleBtn">Настроить список строк</button>
              <span class="help" aria-label="Подсказка">?
                <span class="tip">Скрываются только конкретные экземпляры строк. Используйте экспорт/импорт для переноса настроек.</span>
              </span>
            </div>
          </div>
          <div class="single-row-list" id="singleRowList"></div>
          <div class="single-row-orphans" id="singleRowOrphans" hidden></div>
        </div>
      </div>
    </details>

    <details id="block-typical" open>
      <summary>Фильтр <u>разворачивания</u></summary>
      <div class="panel-body">
        <div class="subsection" id="expandFullSection">
          <div class="subsection-head">
            <div class="subsection-title">Разворачивание всей ветки</div>
            <div class="subsection-actions">
              <button class="btn xs ghost" data-select-all="typical">Выделить всё</button>
              <button class="btn xs ghost" data-select-none="typical">Снять всё</button>
              <button class="btn xs" id="cfgTypicalBtn">Настроить фильтры разворачивания</button>
              <span class="help" aria-label="Подсказка">?
                <span class="tip">Группы определяются по *_grp; также можно указывать точный код узла — его ветка будет считаться группой для разворачивания. Можно загружать/сохранять TXT.</span>
              </span>
            </div>
          </div>
          <div class="settings-row" id="typicalKeysRow" style="margin-top:6px"></div>
        </div>

        <div class="inner-sep"></div>

        <div class="subsection" id="expandOnceSection">
          <div class="subsection-head">
            <div class="subsection-title">Однократное разворачивание</div>
            <div class="subsection-actions">
              <button class="btn xs ghost" data-select-all="typical-once">Выделить всё</button>
              <button class="btn xs ghost" data-select-none="typical-once">Снять всё</button>
              <button class="btn xs" id="cfgTypicalOnceBtn">Настроить «однократное»</button>
              <span class="help" aria-label="Подсказка">?
                <span class="tip">Первая встреча кода раскрывается полностью, остальные остаются свернутыми до ручного показа.</span>
              </span>
            </div>
          </div>
          <div class="settings-row" id="typicalOnceKeysRow" style="margin-top:6px"></div>
        </div>
      </div>
    </details>
  </div>

  <div class="sign-slice">
    <label class="cb-inline"><input type="checkbox" id="sliceToggle"> Показать только выбранную ветку</label>
    <input type="text" id="sliceCode" value="ActInfo">
  </div>

  <div class="tree-controls">
    <label class="cb-inline">Уровень раскрытия:
      <select class="mono" id="autoDepth">
        <option>1</option><option>2</option><option>3</option><option>4</option>
        <option>5</option><option>6</option><option>7</option><option>8</option>
        <option>9</option><option>10</option><option value="all" selected>Все</option>
      </select>
    </label>
  </div>
  <div class="tree-help">
    <button class="btn xs" id="toggleCompact">Сжать окно дерева</button>
    <div class="help" aria-label="Подсказка">?
      <div class="tip">Навигация: ↑/↓ — строки; →/← — раскрыть/свернуть; Enter — карточка; Ctrl+клик — раскрыть ветвь. Кнопка «Сжать/Развернуть окно дерева» меняет высоту области дерева.</div>
    </div>
  </div>

  <div class="tree-wrap" id="treeWrap">
    <div class="tree" id="tree"></div>
  </div>

  <div class="line" style="margin-top:12px"></div>
  <div class="settings-row" id="exportSection" style="margin:8px 0; flex-wrap:wrap; gap:8px">
    <button class="btn" data-dl="txt">Экспорт TXT</button>
<button class="btn" data-dl="csv">Экспорт Excel (CSV)</button>

    <button class="btn" data-dl="snap-save">Сохранить snapshot</button>
    <button class="btn" data-dl="snap-load">Загрузить snapshot</button>
    <button class="btn" data-dl="settings-export">Сохранить настройки</button>
    <button class="btn" data-dl="settings-import">Загрузить настройки</button>
    <input type="file" id="snapFile" accept=".json" style="display:none"/>
    <input type="file" id="settingsFile" accept=".json" style="display:none"/>
  </div>
</div>

<div class="card" id="card">
  <h4 id="cardTitle">Карточка узла</h4>
  <div class="kv">
    <div class="k">Имя</div><div class="v" id="c_ru"></div>
    <div class="k">Код</div><div class="v" id="c_en"><code></code></div>
    <div class="k">QName</div><div class="v" id="c_qn"><code></code></div>
    <div class="k">Полный XPath</div><div class="v" id="c_path"><code></code></div>
    <div class="k">Тип</div><div class="v" id="c_type"><span class="type-link"></span></div>
    <div class="k">Обязательность</div><div class="v" id="c_req"><span class="req"></span></div>
    <div class="k">Атрибуты</div><div class="v" id="c_attrs"><span class="hint">—</span></div>
    <div class="k">Фасеты</div><div class="v" id="c_facets"><span class="hint">—</span></div>
    <div class="k">Флаги</div><div class="v" id="c_flags"><span class="hint">—</span></div>
  </div>
  <div class="actions">
    <button class="btn" data-copy="ru">Копировать Имя</button>
    <button class="btn" data-copy="en">Копировать Код</button>
    <button class="btn" data-copy="xpath">Копировать XPath</button>
    <button class="btn" id="cardClose">Закрыть</button>
  </div>
</div>

<div class="flt-menu" id="fltMenu"></div>
<div class="toast" id="toast">—</div>

<dialog id="reportDlg">
  <h3 style="margin:0 0 8px">Отчёт по загруженным схемам</h3>
  <div id="reportBody"></div>
  <div class="dlg-actions"><button class="btn" id="reportClose">Закрыть</button></div>
</dialog>

<dialog id="typicalCfgDlg">
  <h3 style="margin:0 0 8px">Настройка типовых фильтров</h3>
  <textarea id="typicalCodes" style="width:100%; height:160px; font-family:var(--mono); font-size:12px"
    placeholder="Коды через запятую или с новой строки"></textarea>
  <div class="dlg-actions" style="display:flex; justify-content:space-between; gap:8px">
    <div style="display:flex; gap:8px">
      <input type="file" id="typicalTxtFile" accept=".txt" style="display:none"/>
      <button class="btn" id="typicalLoadTxt">Загрузить TXT</button>
      <button class="btn" id="typicalExportTxt">Экспорт TXT</button>
    </div>
    <div style="display:flex; gap:8px">
      <button class="btn" id="typicalCfgCancel">Отмена</button>
      <button class="btn primary" id="typicalCfgApply">Применить</button>
    </div>
  </div>
</dialog>

<dialog id="serviceCfgDlg">
  <h3 style="margin:0 0 8px">Настройка служебных фильтров</h3>
  <textarea id="serviceCodes" style="width:100%; height:180px; font-family:var(--mono); font-size:12px"
    placeholder="Полный список кодов отображения: через запятую или построчно"></textarea>
  <div class="dlg-actions" style="display:flex; justify-content:space-between; gap:8px">
    <div style="display:flex; gap:8px">
      <input type="file" id="serviceTxtFile" accept=".txt" style="display:none"/>
      <button class="btn" id="serviceLoadTxt">Загрузить TXT</button>
      <button class="btn" id="serviceExportTxt">Экспорт TXT</button>
    </div>
    <div style="display:flex; gap:8px">
      <button class="btn" id="serviceCfgCancel">Отмена</button>
      <button class="btn primary" id="serviceCfgApply">Применить</button>
    </div>
  </div>
</dialog>

<dialog id="serviceSingleCfgDlg">
  <h3 style="margin:0 0 8px">Настройка скрытия отдельных строк</h3>
  <textarea id="serviceSingleKeys" style="width:100%; height:180px; font-family:var(--mono); font-size:12px"
    placeholder="Ключи строк (rowUid|pathKey) через запятую или с новой строки"></textarea>
  <div class="dlg-actions" style="display:flex; justify-content:space-between; gap:8px">
    <div style="display:flex; gap:8px">
      <input type="file" id="serviceSingleTxtFile" accept=".txt" style="display:none"/>
      <button class="btn" id="serviceSingleLoadTxt">Загрузить TXT</button>
      <button class="btn" id="serviceSingleExportTxt">Экспорт TXT</button>
    </div>
    <div style="display:flex; gap:8px">
      <button class="btn" id="serviceSingleCfgCancel">Отмена</button>
      <button class="btn primary" id="serviceSingleCfgApply">Применить</button>
    </div>
  </div>
</dialog>

<dialog id="typicalOnceCfgDlg">
  <h3 style="margin:0 0 8px">Настройка «однократного» разворачивания</h3>
  <textarea id="typicalOnceCodes" style="width:100%; height:160px; font-family:var(--mono); font-size:12px"
    placeholder="Коды через запятую или построчно"></textarea>
  <div class="dlg-actions" style="display:flex; justify-content:space-between; gap:8px">
    <div style="display:flex; gap:8px">
      <input type="file" id="typicalOnceTxtFile" accept=".txt" style="display:none"/>
      <button class="btn" id="typicalOnceLoadTxt">Загрузить TXT</button>
      <button class="btn" id="typicalOnceExportTxt">Экспорт TXT</button>
    </div>
    <div style="display:flex; gap:8px">
      <button class="btn" id="typicalOnceCfgCancel">Отмена</button>
      <button class="btn primary" id="typicalOnceCfgApply">Применить</button>
    </div>
  </div>
</dialog>

<dialog id="infoModal">
  <div id="infoModalBody" style="max-width:480px"></div>
  <div class="dlg-actions"><button class="btn" id="infoModalClose">Закрыть</button></div>
</dialog>

<script>
/* ===================== Константы/хранилище ===================== */
const LS_VIEW='xsdv:view';
const LS_FILTER_SERVICE='xsdv:filtersService';
const LS_FILTER_TYPICAL='xsdv:filtersTypical';
const LS_FILTER_TYPICAL_ONCE='xsdv:filtersTypicalOnce';
const LS_LEVEL='xsdv:expandLevel';
const LS_EXP='xsdv:expandedIds';
const LS_SLICE='xsdv:signSlice';
const LS_TYPICAL_CFG='xsdv:typicalCfgSimple';
const LS_TYPICAL_ONCE_CFG='xsdv:typicalOnceCfg';
const LS_SERVICE_ALL='xsdv:serviceAll';
const LS_OVERRIDES='xsdv:filterOverrides';
const LS_TREE_COMPACT='xsdv:treeCompact';
const LS_HIDE_ROWS='xsdv:displayHideRows';
const SLICE_DEFAULT_CODE='ActInfo';

/* Цвета: разные HUE у верхних веток, глубина — светлее */
const BRANCH_HUES = [210,150,30,270,0,190,340,120];
const SAT_BASE  = 78, SAT_FLOOR = 30, STEP_S = 6;
const L_BASE    = 78, L_CEIL    = 96, STEP_L = 3;
const satFor = d => (d<=0? SAT_BASE : Math.max(SAT_FLOOR, SAT_BASE - STEP_S*Math.max(0,d-1)));
const lightFor = d => Math.min(L_CEIL, L_BASE + STEP_L*Math.max(0,d));

/* Вью по умолчанию */
const defaultView={
  showRU:true, showEN:true, showL:false, showType:false, showReq:false, colorLevels:true,
  copyRU:true, copyPath:false, copyEN:true,
  rowFilterDisplay:true, rowFilterExpand:true
};

/* ===================== Состояние ===================== */
const state={
  view: loadJSON(LS_VIEW, defaultView),
  filtersService: loadJSON(LS_FILTER_SERVICE, {}),     // пусто по умолчанию
  filtersTypical: loadJSON(LS_FILTER_TYPICAL, {}),     // пусто по умолчанию
  filtersTypicalOnce: loadJSON(LS_FILTER_TYPICAL_ONCE, {}),
  expandLevel: (localStorage.getItem(LS_LEVEL) || 'all'),
  expanded: new Set(loadJSON(LS_EXP, [])),
  focusedIndex: 0,
  modelRoot: null,
  repo: null,
  slice: normalizeSliceState(loadJSON(LS_SLICE, null)),
  slicePendingReapply: false,
  typicalCodes: loadTypicalCodes(),                    // []
  typicalOnceCodes: loadTypicalOnceCodes(),
  serviceAllCodes: loadServiceAllCodes(),              // []
  filterOverrides: new Set(loadJSON(LS_OVERRIDES, [])),
  treeCompact: (localStorage.getItem(LS_TREE_COMPACT)==='true'),
  hideRows: loadHideRowsState(),
  tempShownRows: new Set(),
  rowKeyIndex: new Map(),
  rowUidIndex: new Map(),
  pathKeyIndex: new Map(),
  oneTimeInfo: { firsts:new Map(), counts:new Map() }
};
state.slicePendingReapply = state.slice.method === 'code';
try{ localStorage.removeItem('xsdv:displayHideRowsPaused'); }catch(_){ }

const buildDiagnostics = { missingTypes: [], missingElements: [] , idXmlCount:0, idBusinessCount:0, unresolvedImports:[] };

/* ===================== Код-листы ===================== */
function loadTypicalCodes(){
  const raw = localStorage.getItem(LS_TYPICAL_CFG);
  if(!raw) return [];
  try{ const arr=JSON.parse(raw); return Array.isArray(arr)? arr.filter(Boolean):[]; }catch(_){ return []; }
}
function saveTypicalCodes(arr){ localStorage.setItem(LS_TYPICAL_CFG, JSON.stringify(arr)); }

function loadTypicalOnceCodes(){
  const raw = localStorage.getItem(LS_TYPICAL_ONCE_CFG);
  if(!raw) return [];
  try{ const arr=JSON.parse(raw); return Array.isArray(arr)? arr.filter(Boolean):[]; }catch(_){ return []; }
}
function saveTypicalOnceCodes(arr){ localStorage.setItem(LS_TYPICAL_ONCE_CFG, JSON.stringify(arr)); }

function loadServiceAllCodes(){
  const raw = localStorage.getItem(LS_SERVICE_ALL);
  if(!raw) return [];
  try{ const arr=JSON.parse(raw); return Array.isArray(arr)? arr.filter(Boolean):[]; }catch(_){ return []; }
}
function saveServiceAllCodes(arr){
  const uniq = Array.from(new Set(arr.map(s=>String(s).trim()).filter(Boolean)));
  localStorage.setItem(LS_SERVICE_ALL, JSON.stringify(uniq));
  state.serviceAllCodes = uniq;
}

function normalizeHideRowsMap(raw){
  const map=new Map();
  if(!raw) return map;
  const add = (key, hidden=true)=>{
    const normalized = normalizeRowKeyInput(key);
    if(!normalized) return;
    map.set(normalized, hidden!==false);
  };
  if(raw instanceof Map){
    raw.forEach((val,key)=> add(key, val));
    return map;
  }
  if(raw instanceof Set){
    raw.forEach(key=> add(key, true));
    return map;
  }
  if(Array.isArray(raw)){
    raw.forEach(item=>{
      if(typeof item==='string'){ add(item, true); return; }
      if(Array.isArray(item) && item.length){ add(item[0], item[1]!==false); return; }
      if(item && typeof item==='object' && 'key' in item){ add(item.key, item.hidden!==false); return; }
      if(item && typeof item==='object'){
        Object.entries(item).forEach(([k,v])=> add(k, v?.hidden!==false && v!==false));
        return;
      }
    });
    return map;
  }
  if(raw && typeof raw==='object'){
    Object.entries(raw).forEach(([k,v])=>{
      if(v && typeof v==='object' && 'hidden' in v){ add(k, v.hidden!==false); }
      else { add(k, v!==false); }
    });
  }
  return map;
}

function loadHideRowsState(){
  const raw = loadJSON(LS_HIDE_ROWS, []);
  return normalizeHideRowsMap(raw);
}

function serializeHideRowsState(){
  if(!(state.hideRows instanceof Map)) state.hideRows = normalizeHideRowsMap(state.hideRows);
  return Array.from(state.hideRows.entries()).map(([key, hidden])=>({ key, hidden:hidden!==false }));
}

function persistHideRows(){
  localStorage.setItem(LS_HIDE_ROWS, JSON.stringify(serializeHideRowsState()));
}

/* ===================== Режим выбора ветки ===================== */
function emptySliceState(){
  return { method:'none', anchorCode:'', anchorQName:'', anchorPath:'', anchorId:'' };
}
function normalizeSliceState(raw){
  const base = emptySliceState();
  if(!raw || typeof raw!=='object') return base;
  const method = raw.method==='code' || raw.method==='actinfo' ? 'code' : 'none';
  const codeRaw = String(raw.anchorCode||'').trim();
  const fallback = String(raw.anchorQName||'').trim();
  const anchorCode = method==='code' ? (codeRaw || fallback || SLICE_DEFAULT_CODE) : (codeRaw || fallback);
  return {
    method,
    anchorCode: anchorCode || '',
    anchorQName: String(raw.anchorQName||''),
    anchorPath: String(raw.anchorPath||''),
    anchorId: String(raw.anchorId||'')
  };
}
function isSliceActive(){ return state.slice.method==='code'; }
function persistSliceState(){ localStorage.setItem(LS_SLICE, JSON.stringify(state.slice)); }
function syncSliceControls(){
  els.sliceToggle.checked = isSliceActive();
  if(!els.sliceInput){ return; }
  const val = state.slice.anchorCode && state.slice.anchorCode.trim() ? state.slice.anchorCode.trim() : SLICE_DEFAULT_CODE;
  if(document.activeElement !== els.sliceInput){
    els.sliceInput.value = val;
  }
}
function findNodeByCodeOrQName(code){
  if(!state.modelRoot || !code) return null;
  const norm = normalize(code);
  let found=null;
  walk(state.modelRoot, n=>{
    if(found) return;
    if(normalize(n.nameEN)===norm) found=n;
  });
  if(found) return found;
  walk(state.modelRoot, n=>{
    if(found) return;
    if(normalize(n.qname)===norm) found=n;
  });
  return found;
}
function findNodeByQNameExact(qn){
  if(!state.modelRoot || !qn) return null;
  const norm = normalize(qn);
  let found=null;
  walk(state.modelRoot, n=>{
    if(found) return;
    if(normalize(n.qname)===norm) found=n;
  });
  return found;
}
function sliceAnchorFromState(){
  if(!isSliceActive() || !state.modelRoot) return null;
  const {anchorId, anchorCode, anchorQName} = state.slice;
  let anchor = anchorId ? getByIdFull(anchorId) : null;
  if(!anchor && anchorCode) anchor = findNodeByCodeOrQName(anchorCode);
  if(!anchor && anchorQName) anchor = findNodeByQNameExact(anchorQName);
  return anchor;
}
function scrollToSliceAnchor(id){
  if(!id) return;
  const row = els.tree?.querySelector(`.row[data-id="${CSS.escape(id)}"]`);
  if(row){
    row.scrollIntoView({behavior:'smooth', block:'center'});
  }
}
function ensureAnchorPathExpanded(anchor){
  if(!anchor || !anchor._id){ return false; }
  const ids=[];
  let cur=anchor._id;
  while(cur){
    ids.push(cur);
    const idx=cur.lastIndexOf('/');
    if(idx<0) break;
    cur=cur.slice(0, idx);
  }
  let changed=false;
  ids.reverse().forEach(id=>{
    if(!state.expanded.has(id)){
      state.expanded.add(id);
      changed=true;
    }
  });
  return changed;
}
function deactivateSlice({persist=true, silent=false}={}){
  state.slice = {
    ...state.slice,
    method:'none',
    anchorId:'',
    anchorQName:'',
    anchorPath:''
  };
  state.slicePendingReapply = false;
  if(persist) persistSliceState();
  syncSliceControls();
  if(!silent){
    // без уведомления — по ТЗ
  }
}
function activateSliceFromInput(){
  if(!state.modelRoot){
    els.sliceToggle.checked = false;
    showToast('Загрузите XSD, чтобы выбрать ветку');
    return;
  }
  const raw = els.sliceInput?.value || '';
  const code = raw.trim();
  if(!code){
    els.sliceToggle.checked = false;
    showToast('Введите код ветки');
    return;
  }
  const anchor = findNodeByCodeOrQName(code);
  if(!anchor){
    els.sliceToggle.checked = false;
    showToast(`Код "${code}" отсутствует в дереве. Проверьте написание.`);
    deactivateSlice({persist:true, silent:true});
    state.slice = { ...state.slice, anchorCode: code };
    persistSliceState();
    syncSliceControls();
    return;
  }
  els.sliceInput.value = code;
  const expanded = ensureAnchorPathExpanded(anchor);
  if(expanded){ saveState(); }
  state.slice = {
    method:'code',
    anchorCode: code,
    anchorQName: anchor.qname || '',
    anchorPath: xpathEN(anchor),
    anchorId: anchor._id || ''
  };
  state.slicePendingReapply = true;
  persistSliceState();
  syncSliceControls();
  withPreservedScroll(()=> renderModel(), anchor._id);
}
function initSliceUI(){
  syncSliceControls();
  if(els.sliceToggle){
    els.sliceToggle.addEventListener('change', ()=>{
      if(els.sliceToggle.checked){
        state.slicePendingReapply = false;
        activateSliceFromInput();
      }else{
        const prevId = state.slice.anchorId || '';
        deactivateSlice({persist:true});
        withPreservedScroll(()=> renderModel(), prevId);
      }
    });
  }
  if(els.sliceInput){
    els.sliceInput.addEventListener('input', ()=>{
      const val = (els.sliceInput.value||'').trim();
      const wasActive = isSliceActive();
      if(wasActive){
        els.sliceToggle.checked = false;
        const prevId = state.slice.anchorId || '';
        deactivateSlice({persist:false, silent:true});
        withPreservedScroll(()=> renderModel(), prevId);
      }
      state.slice = {
        ...state.slice,
        method:'none',
        anchorCode: val,
        anchorId:'',
        anchorQName:'',
        anchorPath:''
      };
      state.slicePendingReapply = false;
      persistSliceState();
    });
  }
}

/* ===================== DOM ===================== */
const els={
  tree: q('#tree'),
  treeWrap:q('#treeWrap'),
  toggleCompact:q('#toggleCompact'),
  filesBadge:q('#filesBadge'), globalsBadge:q('#globalsBadge'), typesBadge:q('#typesBadge'),
  maxDepthBadge:q('#maxDepthBadge'), rowsBadge:q('#rowsBadge'),
  progressWrap:q('#progressWrap'),
  autoDepth:q('#autoDepth'),
  sliceToggle:q('#sliceToggle'),
  sliceInput:q('#sliceCode'),
  toast:q('#toast'),
  reportBtn:q('#reportBtn'), reportDlg:q('#reportDlg'), reportClose:q('#reportClose'), reportBody:q('#reportBody'),
  fileInput:q('#fileInput'), parseBtn:q('#parseBtn'),
  serviceKeysRow:q('#serviceKeysRow'),
  typicalKeysRow:q('#typicalKeysRow'),
  typicalOnceKeysRow:q('#typicalOnceKeysRow'),
  cfgTypicalBtn:q('#cfgTypicalBtn'),
  typicalCfgDlg:q('#typicalCfgDlg'),
  typicalCodesArea:q('#typicalCodes'),
  typicalImportBtn:q('#typicalLoadTxt'), typicalImportFile:q('#typicalTxtFile'),
  typicalExportBtn:q('#typicalExportTxt'),
  typicalCfgCancel:q('#typicalCfgCancel'), typicalCfgApply:q('#typicalCfgApply'),
  cfgServiceBtn:q('#cfgServiceBtn'),
  serviceCfgDlg:q('#serviceCfgDlg'),
  serviceCodesArea:q('#serviceCodes'),
  serviceImportBtn:q('#serviceLoadTxt'), serviceImportFile:q('#serviceTxtFile'),
  serviceExportBtn:q('#serviceExportTxt'),
  serviceCfgCancel:q('#serviceCfgCancel'), serviceCfgApply:q('#serviceCfgApply'),
  cfgServiceSingleBtn:q('#cfgServiceSingleBtn'),
  serviceSingleCfgDlg:q('#serviceSingleCfgDlg'),
  serviceSingleKeysArea:q('#serviceSingleKeys'),
  serviceSingleImportBtn:q('#serviceSingleLoadTxt'), serviceSingleImportFile:q('#serviceSingleTxtFile'),
  serviceSingleExportBtn:q('#serviceSingleExportTxt'),
  serviceSingleCfgCancel:q('#serviceSingleCfgCancel'), serviceSingleCfgApply:q('#serviceSingleCfgApply'),
  singleRowList:q('#singleRowList'),
  singleRowOrphans:q('#singleRowOrphans'),
  cfgTypicalOnceBtn:q('#cfgTypicalOnceBtn'),
  typicalOnceCfgDlg:q('#typicalOnceCfgDlg'),
  typicalOnceCodesArea:q('#typicalOnceCodes'),
  typicalOnceImportBtn:q('#typicalOnceLoadTxt'), typicalOnceImportFile:q('#typicalOnceTxtFile'),
  typicalOnceExportBtn:q('#typicalOnceExportTxt'),
  typicalOnceCfgCancel:q('#typicalOnceCfgCancel'), typicalOnceCfgApply:q('#typicalOnceCfgApply'),
  infoModal:q('#infoModal'), infoModalBody:q('#infoModalBody'), infoModalClose:q('#infoModalClose'),
  fltMenu:q('#fltMenu')
};
let _menuScroller = null;
let _onScrollReposition = null;

function _addMenuRepositioners(handler){
  window.addEventListener('scroll', handler, { passive:true });
  window.addEventListener('resize', handler);
  _menuScroller = fltMenuState.anchor?.closest('#treeWrap') || null;
  if (_menuScroller) _menuScroller.addEventListener('scroll', handler, { passive:true });
}

function _removeMenuRepositioners(handler){
  window.removeEventListener('scroll', handler);
  window.removeEventListener('resize', handler);
  if (_menuScroller){ _menuScroller.removeEventListener('scroll', handler); _menuScroller = null; }
}



/* === обработчики закрытия меню фильтров: клик-вне и Esc === */
function onDocDown(e){
  if (!e.target.closest('#fltMenu') && !e.target.closest('.fbtn') && !e.target.closest('[data-menu-anchor]')) {
    hideFilterMenu();
  }
}
function onEsc(e){
  if (e.key === 'Escape') hideFilterMenu();
}

/* Кнопка разбора активна при наличии файлов */
function syncParseBtnState(){
  const f = els.fileInput.files;
  els.parseBtn.disabled = !(f && f.length > 0);
}
els.fileInput.addEventListener('input',  syncParseBtnState);
els.fileInput.addEventListener('change', syncParseBtnState);
els.fileInput.addEventListener('click', () => { els.fileInput.value = ''; });
syncParseBtnState();

/* Drag&Drop */
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
  e.preventDefault();
  const files = [...(e.dataTransfer?.files || [])].filter(f => /\.xsd$|\.xml$/i.test(f.name));
  if (!files.length) return;
  const dt = new DataTransfer();
  files.forEach(f => dt.items.add(f));
  els.fileInput.files = dt.files;
  syncParseBtnState();
});

/* Массовые переключатели */
document.addEventListener('click',(e)=>{
  const all = e.target.getAttribute('data-select-all');
  const none = e.target.getAttribute('data-select-none');
  const dl = e.target.getAttribute('data-dl');
  if(all){ toggleBlock(all,true); renderModel(); }
  if(none){ toggleBlock(none,false); renderModel(); }
  if (dl === 'csv') { exportCsvCurrentTree(); return; }
  if(dl) handleDownloadAction(dl);
});
function toggleBlock(block, val){
  if(block==='view'){
    document.querySelectorAll('[data-view]').forEach(x=>{
      const k=x.getAttribute('data-view'); state.view[k]=val; x.checked=val;
    });
    saveState();
    withPreservedScroll(()=> renderModel());
    return;
  }
  if(block==='service'){
    document.querySelectorAll('#block-service [data-filter-service]').forEach(x=>{
      const k=x.getAttribute('data-filter-service'); state.filtersService[k]=val; x.checked=val;
    });
    saveFiltersToLS(); withPreservedScroll(()=> renderModel()); return;
  }
  if(block==='service-single'){
    if(!(state.hideRows instanceof Map)) state.hideRows = normalizeHideRowsMap(state.hideRows);
    let changed=false;
    state.hideRows.forEach((hidden, key)=>{
      const currentHidden = hidden!==false;
      const nextHidden = !val;
      if(currentHidden !== nextHidden){
        state.hideRows.set(key, nextHidden);
        changed=true;
      }
    });
    if(changed){ persistHideRows(); }
    withPreservedScroll(()=> renderModel());
    return;
  }
  if(block==='typical'){
    document.querySelectorAll('#block-typical [data-filter-typical]').forEach(x=>{
      const k=x.getAttribute('data-filter-typical'); state.filtersTypical[k]=val; x.checked=val;
    });
    saveFiltersToLS(); withPreservedScroll(()=> renderModel()); return;
  }
  if(block==='typical-once'){
    document.querySelectorAll('#block-typical [data-filter-typical-once]').forEach(x=>{
      const k=x.getAttribute('data-filter-typical-once'); state.filtersTypicalOnce[k]=val; x.checked=val;
    });
    saveFiltersToLS(); withPreservedScroll(()=> renderModel()); return;
  }
}

/* Чекбоксы «Настройки отображения» — без сброса позиции */
document.addEventListener('change',(e)=>{
  const t = e.target;
  if(t.matches('[data-view]')){
    state.view[t.getAttribute('data-view')] = t.checked; saveState();
    withPreservedScroll(()=> renderModel());
  }
  if(t.matches('#autoDepth')){
    state.expandLevel=t.value; localStorage.setItem(LS_LEVEL, state.expandLevel);
    if(state.modelRoot){
      state.expanded.clear(); state.expanded.add(state.modelRoot._id);
      autoExpandToLevel();
      withPreservedScroll(()=> renderModel());
    }
  }
});
initSliceUI();

/* ========= Разбор XSD ========= */
els.parseBtn.addEventListener('click', parseFiles);

async function parseFiles(){
  const files = Array.from(els.fileInput.files||[]);
  if(!files.length){ showToast('Выберите файлы XSD'); return; }
  showProgress(true);
  try{
    const texts = await Promise.all(files.map(f=>f.text()));
    const repo = buildXsdRepo(files.map((f,i)=>({name:f.name, text:texts[i]})));
    state.repo = repo;

    const rootElem = pickRootElement(repo);
    if(!rootElem){ showToast('Не найден корневой глобальный элемент'); showProgress(false); return; }

    const rootNode = buildModelFromElement(repo, rootElem);
    annotateIdsPathsAndBranch(rootNode);
    inferTypicalGroupContainers(rootNode);
    annotateRequiredness(rootNode);

    state.modelRoot = rootNode;
    if(state.slice.method==='code') state.slicePendingReapply = true;

    /* Полное раскрытие по умолчанию */
    state.expanded.clear();
    state.expanded.add(state.modelRoot._id);
    state.expandLevel = localStorage.getItem(LS_LEVEL) || 'all';
    autoExpandToLevel();
    if(state.slice.method==='code'){
      const anchor = sliceAnchorFromState();
      if(anchor){
        const expanded = ensureAnchorPathExpanded(anchor);
        if(expanded){ saveState(); }
      }
    }

    refreshStatsFromRepo(repo, rootNode);
    renderModel();
  }catch(err){
    console.error(err);
    showToast('Ошибка разбора XSD');
  }finally{
    showProgress(false);
  }
}

/* ========= Репозиторий XSD (сокр.) ========= */
function buildXsdRepo(items){
  const parser = new DOMParser(); const XS_NS="http://www.w3.org/2001/XMLSchema";
  const baseIndex=new Map(), nsTailIndex=new Map();

  const docs = items.map(it=>{
    const doc = parser.parseFromString(it.text,"application/xml");
    const err = doc.getElementsByTagName('parsererror')[0];
    if(err) throw new Error(`XML parsererror в ${it.name}: ${err.textContent.slice(0,200)}`);
    const schema = doc.documentElement && localName(doc.documentElement)==='schema' ? doc.documentElement : null;
    if(!schema) throw new Error('Не найден xs:schema в '+it.name);
    const tns = schema.getAttribute('targetNamespace')||'';
    const basename = (it.name||'').split(/[\\\/]/).pop();
    baseIndex.set(basename.toLowerCase(), {name:basename, doc, schema, tns});
    const tail = tailOfNS(tns); if(tail) nsTailIndex.set(tail, tns);
    return {name:basename, doc, schema, tns};
  });

  const elements=new Map(), types=new Map(), byLocalElements=new Map(), byLocalTypes=new Map();
  for(const d of docs){
    const xs=(sel)=>Array.from(d.schema.getElementsByTagNameNS(XS_NS, sel));
    for(const el of xs('element')){
      if(el.parentElement===d.schema){
        const name=el.getAttribute('name'); if(!name) continue;
        const key=keyQL(d.tns, name); const rec={doc:d,node:el,ns:d.tns,name};
        elements.set(key, rec); pushMap(byLocalElements, name, rec);
      }
    }
    for(const ct of xs('complexType')){
      if(ct.parentElement===d.schema){
        const name=ct.getAttribute('name'); if(!name) continue;
        const key=keyQL(d.tns, name); const rec={doc:d,node:ct,ns:d.tns,name,simple:false};
        types.set(key, rec); pushMap(byLocalTypes, name, rec);
      }
    }
    for(const st of xs('simpleType')){
      if(st.parentElement===d.schema){
        const name=st.getAttribute('name'); if(!name) continue;
        const key=keyQL(d.tns, name); const rec={doc:d,node:st,ns:d.tns,name,simple:true};
        types.set(key, rec); pushMap(byLocalTypes, name, rec);
      }
    }
  }

  const unresolvedImports=[];
  const basenameNsMap=new Map();
  for(const d of docs){ basenameNsMap.set(d.name.toLowerCase(), d.tns||''); }
  for(const d of docs){
    const imps=[...d.schema.getElementsByTagNameNS(XS_NS,'import'), ...d.schema.getElementsByTagNameNS(XS_NS,'include')];
    for(const imp of imps){
      const href=imp.getAttribute('schemaLocation')||imp.getAttribute('href')||'';
      if(!href) continue;
      const base=href.split(/[\\\/]/).pop().toLowerCase();
      if(!basenameNsMap.has(base)){ unresolvedImports.push({from:d.name, href, ns: imp.getAttribute('namespace')||'', type: localName(imp)}); }
    }
  }

  function resolveElement(ctx, qn){
    const {ns,local,pref}=splitQNameEx(ctx, qn);
    let key=keyQL(ns,local); if(elements.has(key)) return elements.get(key);
    const tail=tailOfNS(ns); if(tail && nsTailIndex.has(tail)){ key=keyQL(nsTailIndex.get(tail),local); if(elements.has(key)) return elements.get(key); }
    const base=guessBasenameFromPrefix(pref); if(base && basenameNsMap.has(base)){ key=keyQL(basenameNsMap.get(base),local); if(elements.has(key)) return elements.get(key); }
    const list=byLocalElements.get(local)||[]; if(list.length===1) return list[0];
    buildDiagnostics.missingElements.push(`${qn} @${ctx.baseURI||''}`); return null;
  }
  function resolveType(ctx, qn){
    const {ns,local,pref}=splitQNameEx(ctx, qn);
    let key=keyQL(ns,local); if(types.has(key)) return types.get(key);
    const tail=tailOfNS(ns); if(tail && nsTailIndex.has(tail)){ key=keyQL(nsTailIndex.get(tail),local); if(types.has(key)) return types.get(key); }
    const base=guessBasenameFromPrefix(pref); if(base && basenameNsMap.has(base)){ key=keyQL(basenameNsMap.get(base),local); if(types.has(key)) return types.get(key); }
    const list=byLocalTypes.get(local)||[]; if(list.length===1) return list[0];
    buildDiagnostics.missingTypes.push(`${qn} @${ctx.baseURI||''}`); return null;
  }

  return {docs,elements,types,byLocalElements,byLocalTypes,XS_NS,baseIndex,unresolvedImports,basenameNsMap,nsTailIndex,resolveElement,resolveType};
}

/* ========= Выбор корня ========= */
function pickRootElement(repo){
  let byName=[...repo.elements.values()].find(e=>/^atiso$/i.test(e.name)) ||
             [...repo.elements.values()].find(e=>/hiddenworkact/i.test(e.name));
  if(byName) return byName;
  const firstDoc = repo.docs[0];
  for(const e of repo.elements.values()){ if(e.doc===firstDoc) return e; }
  return repo.elements.values().next().value || null;
}

/* ========= Построение модели ========= */
function buildModelFromElement(repo, elRef, depth=0){
  const el=elRef.node, tns=elRef.ns||'';
  const qn = makeQName(el.ownerDocument, tns, el.getAttribute('name'));
  const typeAttr = el.getAttribute('type');

  const ruFromEl = readHumanLabel(el);
  let ruFromType='';
  if(typeAttr){
    const t=repo.resolveType(el, typeAttr);
    if(t){ ruFromType = readHumanLabel(t.node); }
  }

  const nameEN = el.getAttribute('name') || 'element';
  const node = {
    nameRU: ruFromEl || ruFromType || prettifyName(nameEN),
    nameEN: nameEN,
    qname: qn,
    type: typeAttr ? resolveQNameStr(el, typeAttr) : '',
    minOccurs: intOr(el.getAttribute('minOccurs'), 1),
    maxOccurs: el.getAttribute('maxOccurs') || 1,
    level: depth,
    signable: !/http:\/\/www\.w3\.org\/2000\/09\/xmldsig#/.test(el.namespaceURI || '') && !/^ds:|^Signature$/i.test(nameEN),
    service:  /^ds:|^Signature$/i.test(nameEN),
    annotation: !!findChild(el, repo.XS_NS, 'annotation'),
    documentation: !!el.getElementsByTagNameNS(repo.XS_NS,'documentation').length,
    hasAssert: !!el.getElementsByTagNameNS(repo.XS_NS,'assert').length,
    children:[]
  };

  const localCT = findChild(el, repo.XS_NS,'complexType');
  if(localCT){
    node.type = typeAttr ? resolveQNameStr(el, typeAttr) : makeQName(el.ownerDocument, tns, nameEN+'Type');
    node.children = expandComplexType(state.repo, el.ownerDocument, localCT, depth+1);
    if(!node.hasAssert){ node.hasAssert = !!localCT.getElementsByTagNameNS(repo.XS_NS,'assert').length; }
  }else if(typeAttr){
    const t = state.repo.resolveType(el, typeAttr);
    if(t){
      node.annotation = node.annotation || !!findChild(t.node, repo.XS_NS,'annotation');
      node.documentation = node.documentation || !!t.node.getElementsByTagNameNS(repo.XS_NS,'documentation').length;
      node.hasAssert = node.hasAssert || !!t.node.getElementsByTagNameNS(repo.XS_NS,'assert').length;
      node.children = expandComplexType(state.repo, t.doc.doc, t.node, depth+1);
    }
  }

  markTypicalAndCommonFlags(node);
  markServiceFlags(node);
  return node;
}
function expandComplexType(repo, doc, ctNode, depth){
  const XS=repo.XS_NS; const kids=[];
  const cc=findChild(ctNode, XS,'complexContent');
  if(cc){
    const ext=findChild(cc, XS,'extension');
    if(ext){
      const base=ext.getAttribute('base');
      ['sequence','all','choice'].forEach(k=>{ const p=findChild(ext, XS,k); if(p) kids.push(...expandParticle(repo, doc, p, depth, k, intOr(p.getAttribute('minOccurs'),1))); });
      if(base){ const bt=repo.resolveType(ext, base); if(bt) kids.push(...expandComplexType(repo, bt.doc.doc, bt.node, depth)); }
      return kids;
    }
  }
  ['sequence','all','choice'].forEach(k=>{ const p=findChild(ctNode, XS,k); if(p) kids.push(...expandParticle(repo, doc, p, depth, k, intOr(p.getAttribute('minOccurs'),1))); });
  return kids;
}
function expandParticle(repo, doc, particle, depth, ctx='sequence', ctxMin=1){
  const XS=repo.XS_NS; const out=[];
  for(const el of Array.from(particle.children)){
    if(el.namespaceURI!==XS) continue;
    const ln=localName(el);

    if(ln==='element'){
      const tns=targetNsOf(doc);
      if(el.getAttribute('ref')){
        const refEl=repo.resolveElement(el, el.getAttribute('ref'));
        if(refEl){
          const child=buildModelFromElement(repo, refEl, depth);
          child.minOccurs=intOr(el.getAttribute('minOccurs'), child.minOccurs);
          child.maxOccurs=el.getAttribute('maxOccurs') || child.maxOccurs;
          child.level=depth;
          child.annotation=child.annotation || !!findChild(el, repo.XS_NS,'annotation');
          child.documentation=child.documentation || !!el.getElementsByTagNameNS(repo.XS_NS,'documentation').length;
          child._parentParticle=ctx; child._parentMin=ctxMin;
          out.push(child);
        }
        continue;
      }
      const name=enforce(el.getAttribute('name'),'element');
      const ru=readHumanLabel(el) || prettifyName(name);
      const child={
        nameRU: ru, nameEN: name, qname: makeQName(doc, tns, name),
        type: el.getAttribute('type') ? resolveQNameStr(el, el.getAttribute('type')) : '',
        minOccurs: intOr(el.getAttribute('minOccurs'), 1),
        maxOccurs: el.getAttribute('maxOccurs') || 1,
        level: depth,
        signable: !/^ds:|signature/i.test(name),
        service:  /^ds:|signature/i.test(name),
        annotation: !!findChild(el, repo.XS_NS,'annotation'),
        documentation:!!el.getElementsByTagNameNS(repo.XS_NS,'documentation').length,
        hasAssert: !!el.getElementsByTagNameNS(repo.XS_NS,'assert').length,
        _parentParticle:ctx, _parentMin:ctxMin,
        children:[]
      };
      const lct=findChild(el, XS,'complexType');
      if(lct){
        if(!child.type) child.type=makeQName(doc, tns, name+'Type');
        child.children=expandComplexType(repo, doc, lct, depth+1);
        child.hasAssert = child.hasAssert || !!lct.getElementsByTagNameNS(repo.XS_NS,'assert').length;
      }else if(child.type){
        const def=repo.resolveType(el, child.type);
        if(def){
          child.annotation=child.annotation || !!findChild(def.node, repo.XS_NS,'annotation');
          child.documentation=child.documentation || !!def.node.getElementsByTagNameNS(repo.XS_NS,'documentation').length;
          child.hasAssert=child.hasAssert || !!def.node.getElementsByTagNameNS(repo.XS_NS,'assert').length;
          child.children=expandComplexType(repo, def.doc.doc, def.node, depth+1);
        }
      }
      markTypicalAndCommonFlags(child);
      markServiceFlags(child);
      out.push(child);
    }else if(ln==='choice' || ln==='sequence' || ln==='all'){
      out.push(...expandParticle(repo, doc, el, depth, ln, intOr(el.getAttribute('minOccurs'),1)));
    }else if(ln==='group'){
      const ref=el.getAttribute('ref');
      if(ref){ const t=repo.resolveType(el, ref); if(t) out.push(...expandComplexType(repo, t.doc.doc, t.node, depth)); }
    }
  }
  return out;
}

/* ========= Метки/утилиты модели ========= */
function readHumanLabel(node){
  const ann=findChild(node, "http://www.w3.org/2001/XMLSchema","annotation"); if(!ann) return '';
  const docs=Array.from(ann.getElementsByTagNameNS("http://www.w3.org/2001/XMLSchema","documentation"));
  if(!docs.length) return '';
  let cand=docs.find(d=>(d.getAttributeNS("http://www.w3.org/XML/1998/namespace","lang")||'').toLowerCase().startsWith('ru'));
  if(!cand) cand=docs.find(d=>/[А-Яа-яЁё]/.test(d.textContent||'')); if(!cand) cand=docs[0];
  return (cand.textContent||'').trim().replace(/\s+/g,' ');
}
function prettifyName(code){
  if(!code) return '';
  return String(code).replace(/[_\-]+/g,' ')
    .replace(/([a-z0-9])([A-Z])/g,'$1 $2')
    .replace(/([A-Z]+)([A-Z][a-z])/g,'$1 $2')
    .toLowerCase()
    .replace(/(^|\s)\S/g, m=>m.toUpperCase());
}
function keyQL(ns, local){ return `{${ns||''}}${local||''}` }
function localName(node){ return node.localName || node.nodeName.split(':').pop() }
function targetNsOf(doc){ const s=doc.getElementsByTagNameNS("http://www.w3.org/2001/XMLSchema",'schema')[0]; return s?(s.getAttribute('targetNamespace')||''):'' }
function findChild(node, ns, ln){ return Array.from(node.children).find(n=>n.namespaceURI===ns && localName(n)===ln) || null }
function splitQNameEx(contextNode, qname){
  if(!qname) return {ns:'', local:'', pref:''};
  if(qname.indexOf(':')<0){ const ns=contextNode.lookupNamespaceURI(null)||''; return {ns,local:qname,pref:''}; }
  const [pref,local]=qname.split(':'); const ns=contextNode.lookupNamespaceURI(pref)||''; return {ns,local,pref};
}
function resolveQNameStr(contextNode, qname){ const {ns,local}=splitQNameEx(contextNode,qname); const pref=contextNode.lookupPrefix(ns)||guessPrefix(ns)||'ns'; return `${pref}:${local}`; }
function makeQName(doc, ns, local){ const pref=doc.documentElement.lookupPrefix(ns)||guessPrefix(ns)||'ns'; return `${pref}:${local}`; }
function guessPrefix(ns){
  if(ns === 'http://www.w3.org/2001/XMLSchema') return 'xs';
  if(/xmldsig/i.test(ns)) return 'ds';
  const m = /\/([A-Za-z0-9_.:-]+)$/.exec(ns || '');
  const tail = m ? m[1] : '';
  const cleaned = tail.replace(/[^A-Za-z0-9_]/g, '');
  return cleaned || 'ns';
}
function tailOfNS(ns){ if(!ns) return ''; const m=/\/([^/]+)$/.exec(ns); return m? m[1].toLowerCase():''; }
function guessBasenameFromPrefix(pref){ if(!pref) return ''; if(/ct|common/i.test(pref)) return 'commontypes.xsd'; if(/bt|basetypes/i.test(pref)) return 'basetypes.xsd'; if(/bd|basedocument/i.test(pref)) return 'basedocument.xsd'; return ''; }
function intOr(v,d){ const n=parseInt(v,10); return isNaN(n)? d:n }
function pushMap(map,key,val){ if(!map.has(key)) map.set(key,[]); map.get(key).push(val); }
function enforce(v,alt){ return v!=null ? v : alt }

/* ========= Типовые/служебные ========= */
function getTypicalList(){ return Array.from(state.typicalCodes||[]); }
function getOneTimeList(){ return Array.from(state.typicalOnceCodes||[]); }
function getServiceList(){ return Array.from(state.serviceAllCodes||[]); }
function getAllGroupCodes(){
  return Array.from(new Set([...getTypicalList(), ...getOneTimeList()]));
}

function markTypicalAndCommonFlags(n){
  const en=(n.nameEN||'').toLowerCase(), ru=(n.nameRU||'').toLowerCase();

  if(/\bsignature\b/.test(en) || /^ds:signature/i.test(n.qname||'')) n.signature=true;
  if(/\bkeyinfo\b/.test(en)   || /^ds:keyinfo/i.test(n.qname||''))   n.keyInfo=true;
  if(/\bschemaversion\b/.test(en) || /версия схем/.test(ru)) n.schemaVersion=true;
  if(/\bguid\b|\buuid\b/.test(en) || /\bguid\b|\buuid\b/.test(ru)) n.guid=true;
  if(/\b(xs:)?(id|idref|idrefs)\b/.test((n.type||'').toLowerCase())){ n.idXml=true; buildDiagnostics.idXmlCount++; }
  if(!n.idXml && (/(^|[_-])id($|[_-])|\bnumber\b|\bdocnumber\b|\breg(istration)?(no|number)?\b|\bact(number)?\b|\brecord(number)?\b/i.test(en))){
    n.idBusiness=true; buildDiagnostics.idBusinessCount++;
  }
  if(!/^ds:/.test(n.qname||'') && (/(^|:)(xs:)?date(time)?$/.test((n.type||'').toLowerCase()) || /\bdate\b|\btime\b|\bissued\b|\bsigned\b|\bcreated\b|\bupdated\b|\bchecked\b/.test(en) || /\bдата\b|\бвремя\b|\bподписан\b|\bпроверен\b/.test(ru))){
    n.dateTime=true;
  }
  if(/\bobject(info)?\b|\bconstructionobject\b|\bsite\b|\bfacility\b|\bobjectid\b/.test(en) || /\bобъект\b/.test(ru)) n.object=true;

  for(const code of getAllGroupCodes()){
    const rx = new RegExp(`\\b${escapeRx(code)}\\b`, 'i');
    if(rx.test(en) || rx.test(ru)) n[code]=true;
  }
}
function markServiceFlags(n){
  const en=(n.nameEN||'').toLowerCase(), ru=(n.nameRU||'').toLowerCase();
  for(const code of getServiceList()){
    const rx = new RegExp(`\\b${escapeRx(code)}\\b`, 'i');
    if(rx.test(en) || rx.test(ru)) n[code]=n[code]||false;
  }
}

/* Перемаркировка */
function reindexFlagsAll(){
  if(!state.modelRoot) return;
  const typical = new Set(getAllGroupCodes());
  const service = new Set(getServiceList());
  walk(state.modelRoot, n=>{
    typical.forEach(k=>{ delete n[k]; delete n[k+'_grp']; });
    service.forEach(k=>{ delete n[k]; });
    delete n.idXml; delete n.idBusiness; delete n.dateTime; delete n.guid; delete n.schemaVersion;
    delete n.signature; delete n.keyInfo; delete n.object; delete n.wrapper;
  });
  walk(state.modelRoot, n=>{ markTypicalAndCommonFlags(n); markServiceFlags(n); });
  inferTypicalGroupContainers(state.modelRoot);
}

/* Контейнеры типовых групп */
function inferTypicalGroupContainers(root){
  const codes=getAllGroupCodes();
  walk(root, n=>{ codes.forEach(code=> delete n[code+'_grp']); });
  walk(root, n=>{
    const en=(n.nameEN||'').toLowerCase(), ru=(n.nameRU||'').toLowerCase();
    codes.forEach(code=>{
      const rx=new RegExp(`\\b${escapeRx(code)}\\b`,'i');
      if(rx.test(en) || rx.test(ru)) n[code+'_grp']=true;
    });
  });
  walk(root, n=>{
    const kids=(n.children||[]);
    codes.forEach(code=>{
      const rx=new RegExp(`\\b${escapeRx(code)}\\b`,'i');
      const score=kids.filter(k=> rx.test((k.nameEN||'').toLowerCase()) || rx.test((k.nameRU||'').toLowerCase())).length;
      if(score>=2) n[code+'_grp']=true;
    });
  });
}
function escapeRx(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

/* Обязательность */
function annotateRequiredness(root){
  function dfs(n, ancOpt){
    let req='required';
    if((n.minOccurs??1)===0) req='optional';
    if(ancOpt) req='optional';
    if(n._parentParticle==='choice' && (n._parentMin??1)>=1) req='conditional';
    if(n.hasAssert && req==='required') req='conditional';
    n.req=req;
    const nextOpt = ancOpt || ((n.minOccurs??1)===0) || (n._parentParticle!=='choice' && (n._parentMin??1)===0);
    (n.children||[]).forEach(ch=>dfs(ch, nextOpt));
  }
  dfs(root,false);
}

/* ===================== Фильтрация ===================== */
const normalize = s => String(s||'').trim().toLowerCase();
function nodeMatchesServiceCode(n, code){ return normalize(n.nameEN) === normalize(code); }

function filterService(node, FS, isRoot=false){
  function pass(n, rootFlag){
    if(rootFlag) return true;
    for(const code of Object.keys(FS||{})){
      if(FS[code]===false && nodeMatchesServiceCode(n, code)) return false;
    }
    return true;
  }
  function dfs(n, rootFlag){
    if(!pass(n,rootFlag)) return null;
    const kids=(n.children||[]).map(ch=>dfs(ch,false)).filter(Boolean);
    return {...n, children:kids};
  }
  return dfs(node, isRoot);
}

function applySingleRowVisibility(root){
  if(!root) return null;
  if(!(state.hideRows instanceof Map)){
    state.hideRows = normalizeHideRowsMap(state.hideRows);
  }
  const hideMap = state.hideRows;
  const tempSet = new Set(Array.from(state.tempShownRows||[]));
  const rootKey = rowKeyFor(root);

  const isHiddenKey = (key)=>{
    if(!key || key===rootKey) return false;
    if(!hideMap.has(key)) return false;
    return hideMap.get(key)!==false;
  };

  function dfs(node, hiddenCount, parentHiddenInfo){
    const key = rowKeyFor(node);
    const hidden = isHiddenKey(key) && !tempSet.has(key);
    const nextHiddenCount = hiddenCount + (hidden ? 1 : 0);
    const immediateHiddenInfo = hidden ? { key, title: node.nameRU || node.nameEN || '' } : null;
    const childrenCombined = [];
    (node.children||[]).forEach(child=>{
      const res = dfs(child, nextHiddenCount, immediateHiddenInfo);
      childrenCombined.push(...res);
    });
    if(hidden){
      childrenCombined.forEach(ch=>{
        if(ch){
          ch._parentHiddenLabel = immediateHiddenInfo;
        }
      });
      return childrenCombined;
    }
    const baseDepth = depthOf(node);
    const adjustedDepth = Math.max(0, baseDepth - hiddenCount);
    const clone = {...node, children:childrenCombined, _depth: adjustedDepth};
    clone.level = adjustedDepth;
    if(parentHiddenInfo){
      clone._parentHiddenLabel = parentHiddenInfo;
    }else if('_parentHiddenLabel' in clone){
      delete clone._parentHiddenLabel;
    }
    return [clone];
  }

  const processed = dfs(root, 0, null);
  return processed[0] || null;
}

/* Разворачивание групп */
function applyTypicalGroupExpand(node, FT, FS){
  const keys = getTypicalList();
  const isGrpByFlag = keys.some(k=> node[k+'_grp']);
  const isGrpByExact = keys.some(k=> normalize(node.nameEN)===normalize(k));
  const isGrp = isGrpByFlag || isGrpByExact;

  const overridden = state.filterOverrides.has(node._id);
  let children = (node.children||[]).map(ch=>applyTypicalGroupExpand(ch, FT, FS)).filter(Boolean);

  if(isGrp){
    const blocked = keys.some(k=> (node[k+'_grp'] || normalize(node.nameEN)===normalize(k)) && (FS?.[k]===false));
    if(!blocked){
      const on = keys.some(k=> (node[k+'_grp'] || normalize(node.nameEN)===normalize(k)) && FT[k]!==false);
      if(!on && !overridden){
        return {...node, _filteredCollapse:true, children:[]};
      }
    }
  }
  return {...node, _filteredCollapse:false, children};
}

function applyOneTimeExpand(node){
  if(!node) return null;
  const codes = getOneTimeList();
  const info = state.oneTimeInfo || { firsts:new Map(), counts:new Map() };
  const firstMap = info.firsts || new Map();
  const countMap = info.counts || new Map();

  function dfs(n){
    if(!n) return null;
    const normName = normalize(n.nameEN);
    let kids = (n.children||[]).map(dfs).filter(Boolean);
    let clone = {...n, children:kids};
    const totalForNode = normName ? (countMap.get(normName) || 0) : 0;
    if(totalForNode>=2){
      clone._oneTimeOccurrences = totalForNode;
    }else if('_oneTimeOccurrences' in clone){
      delete clone._oneTimeOccurrences;
    }

    const match = matchCodeFromList(n, codes);
    if(!match) return clone;

    const { code, normalized } = match;
    clone._oneTimeCode = code;
    clone._oneTimeCodeNorm = normalized;
    const total = countMap.get(normalized) || 0;
    if(total>=2){
      clone._oneTimeOccurrences = total;
    }
    const active = state.filtersTypicalOnce[code]!==false;
    const blockedByService = state.filtersService[code]===false;
    if(!active || blockedByService || total<=0){
      return clone;
    }
    const firstId = firstMap.get(normalized) || '';
    clone._oneTimeFirstId = firstId;
    const isFirst = firstId === n._id;
    if(total<=1){
      clone._oneTimeFirst = true;
      return clone;
    }
    if(isFirst){
      clone._oneTimeFirst = true;
      if(state.filtersTypical[code]!==false){
        clone._oneTimeFullAlso = true;
      }
      return clone;
    }
    if(state.filterOverrides.has(n._id)){
      clone._oneTimeOverride = true;
      return clone;
    }
    clone._oneTimeHidden = true;
    clone._filteredCollapse = true;
    clone.children = [];
    return clone;
  }

  return dfs(node);
}

/* ===================== Вспомогательные модели ===================== */
function deepClone(n){ return {...n, children:(n.children||[]).map(deepClone)} }
function walkLocal(n, fn, d=1){ fn(n,d); (n.children||[]).forEach(ch=>walkLocal(ch,fn,d+1)); }
function walk(n,fn){ if(!n) return; fn(n); (n.children||[]).forEach(ch=>walk(ch,fn)); }  /* исправлено */

function composeRowKey(uid, pathKey){
  const cleanUid = String(uid||'').trim();
  const cleanPath = String(pathKey||'').trim();
  return `${cleanUid}|${cleanPath}`;
}

function registerRowKey(node, pathKey){
  const uid = node.rowUid!=null ? String(node.rowUid).trim() : '';
  node._rowUid = uid;
  node._pathKey = pathKey;
  node._rowKey = composeRowKey(uid, pathKey);
  if(pathKey) state.pathKeyIndex.set(pathKey, node);
  if(uid) state.rowUidIndex.set(uid, node);
  state.rowKeyIndex.set(node._rowKey, node);
}

function annotateIdsPathsAndBranch(node){
  state.rowKeyIndex = new Map();
  state.rowUidIndex = new Map();
  state.pathKeyIndex = new Map();

  const rootSeg = node.nameEN||'root';
  node._id = rootSeg;
  node._pathEN = rootSeg;
  node._depth = node.level ?? 0;
  node._branch = -1;
  const rootPathKey = `${rootSeg}#0`;
  registerRowKey(node, rootPathKey);

  (node.children||[]).forEach((ch, idx)=> propagateAnnot(ch, node._id, rootPathKey, idx, idx));
}
function propagateAnnot(n, parentId, parentPathKey, localIndex, branchIndex){
  const seg=n.nameEN||'node';
  const id = `${parentId}/${seg}#${localIndex}`;
  const pathKey = `${parentPathKey}/${seg}#${localIndex}`;
  n._id = id;
  n._pathEN = id;
  n._depth = (n.level ?? 0);
  n._branch = branchIndex;
  registerRowKey(n, pathKey);
  (n.children||[]).forEach((ch,i)=> propagateAnnot(ch, id, pathKey, i, branchIndex));
}
function depthOf(n){ return n.level ?? n._depth ?? 0 }

function rowKeyFor(node){
  if(!node) return '';
  if(node._rowKey) return node._rowKey;
  return composeRowKey(node._rowUid||'', node._pathKey||'');
}

function normalizeRowKeyInput(raw){
  if(raw==null) return '';
  const str = String(raw).trim();
  if(!str) return '';
  const parts = str.split('|');
  if(parts.length<=1){
    return composeRowKey('', parts[0]);
  }
  const uid = parts.shift();
  const path = parts.join('|');
  return composeRowKey(uid, path);
}

function resolveRowKey(key){
  const normalized = normalizeRowKeyInput(key);
  const parts = normalized.split('|');
  const uid = parts.shift()||'';
  const pathKey = parts.join('|');
  let node=null; let matchedBy='';
  if(uid && state.rowUidIndex.has(uid)){ node=state.rowUidIndex.get(uid); matchedBy='uid'; }
  if(!node && pathKey && state.pathKeyIndex.has(pathKey)){ node=state.pathKeyIndex.get(pathKey); matchedBy=matchedBy||'path'; }
  return { node: node||null, rowUid:uid, pathKey, matchedBy, key:normalized };
}

function formatRowPathLabel(path){
  const str = String(path||'').trim();
  if(!str) return '—';
  const parts = str.split('/');
  if(parts.length<=3) return str;
  return '…/'+parts.slice(-3).join('/');
}

function showHiddenRowTemporarily(key, {scroll=false}={}){
  const info = resolveRowKey(key);
  if(!info.node){
    showToast('Строка не найдена в текущем дереве');
    return;
  }
  const normalized = info.key;
  const id = info.node._id;
  state.tempShownRows.add(normalized);
  withPreservedScroll(()=> renderModel(), id);
  const row = els.tree.querySelector(`.row[data-id="${CSS.escape(id)}"]`);
  if(!row){
    showToast('Строка скрыта другими фильтрами');
    return;
  }
  if(scroll){
    row.scrollIntoView({behavior:'smooth', block:'center'});
  }
  row.setAttribute('aria-selected','true');
}

function jumpToFirstOccurrence(firstId, code){
  if(!firstId) return;
  const row = els.tree.querySelector(`.row[data-id="${CSS.escape(firstId)}"]`);
  if(row){
    row.scrollIntoView({behavior:'smooth', block:'center'});
    $$('#tree .row').forEach(r=>r.setAttribute('aria-selected','false'));
    row.setAttribute('aria-selected','true');
    return;
  }
  const message = code ? `Первая встреча скрыта активными фильтрами. Измените фильтры (код: ${code}) и повторите переход.`
                        : 'Первая встреча скрыта активными фильтрами. Измените фильтры и повторите переход.';
  showModalMessage(message);
}

/* ===================== Рендер ===================== */
const elsAutoDepth=q('#autoDepth');
function autoExpandToLevel(){
  const lvl=state.expandLevel==='all'? Infinity : parseInt(state.expandLevel,10);
  walk(state.modelRoot, n=>{
    const d=depthOf(n);
    if(d<lvl && ((n.children||[]).length || n._filteredCollapse)) state.expanded.add(n._id);
  });
}

let flat=[];
let suppressFocusScroll=false;

function renderModel(){
  buildServiceFilterCheckboxes();
  buildTypicalFilterCheckboxes();
  buildTypicalOnceFilterCheckboxes();
  buildSingleRowList();

  const sliceWasActive = isSliceActive();
  const pendingBefore = state.slicePendingReapply;
  let missingAnchorMessage = null;

  if(sliceWasActive && state.modelRoot){
    const anchor = sliceAnchorFromState();
    if(!anchor){
      if(pendingBefore){
        const code = (state.slice.anchorCode||'').trim();
        missingAnchorMessage = code ? `Код "${code}" отсутствует в дереве. Проверьте написание.` : 'Ветка не найдена.';
      }
      deactivateSlice({persist:true, silent:true});
    }else{
      if(state.slicePendingReapply){
        const expanded = ensureAnchorPathExpanded(anchor);
        if(expanded){ saveState(); }
      }
      const prevSlice = state.slice;
      const normalizedCode = (prevSlice.anchorCode && prevSlice.anchorCode.trim()) || anchor.nameEN || '';
      const nextSlice = {
        method:'code',
        anchorCode: normalizedCode,
        anchorQName: anchor.qname || '',
        anchorPath: xpathEN(anchor),
        anchorId: anchor._id || ''
      };
      const changed = ['method','anchorCode','anchorQName','anchorPath','anchorId'].some(key=> prevSlice[key] !== nextSlice[key]);
      state.slice = nextSlice;
      if(changed){
        persistSliceState();
        syncSliceControls();
      }
    }
  }

  const model = filteredTree();
  flat=[]; els.tree.innerHTML='';

  if(!model){
    updateBadgesCounts();
    setMaxDepth(0); setRowsTotal(0);
    if(missingAnchorMessage) showToast(missingAnchorMessage);
    return;
  }

  state.expanded.add(model._id);

  function renderNode(node){
    flat.push(node);
    const row=ce('div','row'); row.dataset.id=node._id; row.dataset.type=node.type||''; row.dataset.path=xpathEN(node);

    if(state.view.colorLevels){
      const depth=depthOf(node);
      const hue = BRANCH_HUES[Math.max(0, (node._branch ?? 0)) % BRANCH_HUES.length];
      const S = satFor(depth);
      const L = lightFor(depth);
      row.style.backgroundColor = `hsla(${hue}, ${S}%, ${L}%, .92)`;
    }else{
      row.style.backgroundColor = 'transparent';
    }

    const depth=depthOf(node);
    const left=ce('div','left'); left.style.paddingLeft=`${depth*20}px`;

    const hasChildren=(node.children||[]).length>0;
    const caret=ce('div','caret');
    if(hasChildren || node._filteredCollapse){ caret.textContent= state.expanded.has(node._id)? '▼':'▶'; caret.setAttribute('role','button'); caret.title='Раскрыть/свернуть'; }
    else{ caret.classList.add('empty'); caret.textContent=''; }

    const dot=ce('div','dot'); dot.title='Открыть карточку узла';
    const content=ce('div','content');

    const hasRU = !!(node.nameRU && node.nameRU.trim());
    const nameRU = hasRU ? ce('span','nameRU', node.nameRU) : null;
    const nameEN = ce('span','nameEN', (state.view.showEN && node.nameEN)? `• ${node.nameEN}` : '');

    if(state.view.showRU && hasRU) content.appendChild(nameRU);
    if(state.view.showEN && node.nameEN) content.appendChild(nameEN);

    if(state.view.showType && node.type) content.appendChild(ce('span','type', node.type||''));
    if(state.view.showReq){
      const req=ce('span','req');
      const r=node.req||'optional';
      req.textContent = r==='required'?'Обяз.':(r==='conditional'?'Условно':'Необяз.');
      req.className='req req-'+r;
      content.appendChild(req);
    }
    if(state.view.showL) content.appendChild(ce('span','badge-mini','L'+depth));

    if(node._parentHiddenLabel){
      const badge=document.createElement('button');
      badge.type='button';
      badge.className='badge-mini parent-hidden-trigger';
      badge.textContent='Родитель скрыт';
      badge.title = node._parentHiddenLabel.title || '';
      badge.setAttribute('data-menu-anchor','true');
      badge.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        openHiddenParentMenu(ev.currentTarget, node);
      });
      content.appendChild(badge);
    }
    if(node._oneTimeFirst && node._oneTimeFullAlso){
      const badge=ce('span','badge-mini','Код в «однократном»; полная ветка показана один раз');
      content.appendChild(badge);
    }

    if(node._filteredCollapse){
      if(node._oneTimeHidden){
        const badge=ce('span','badge-mini','Однократное: показано ранее');
        content.appendChild(badge);
        if(node._oneTimeFirstId){
          const wrap=ce('span','single-row-note','Отображено ранее: ');
          const jumpBtn=ce('button','btn micro','Перейти');
          jumpBtn.addEventListener('click', ()=>{
            jumpToFirstOccurrence(node._oneTimeFirstId, node._oneTimeCode||'');
          });
          wrap.appendChild(jumpBtn);
          content.appendChild(wrap);
        }
        const btn=ce('button','btn xs','Отобразить один раз');
        btn.addEventListener('click', ()=>{
          const id = node._id;
          withPreservedScroll(()=>{
            state.filterOverrides.add(id);
            persistOverrides();
            renderModel();
          }, id);
        });
        content.appendChild(btn);
      }else{
        const badge=ce('span','badge-mini','Свернуто фильтром');
        const hiddenRows = countHiddenRowsForFilteredNode(node._id);
        const badgeRows = ce('span','badge-mini', `Скрыто строк: ${hiddenRows}`);
        const btn=ce('button','btn xs','Показать временно');
        btn.addEventListener('click', ()=>{
          const id = node._id;
          withPreservedScroll(()=>{
            state.filterOverrides.add(id);
            persistOverrides();
            renderModel();
          }, id);
        });
        content.appendChild(badge);
        content.appendChild(badgeRows);
        content.appendChild(btn);
      }
    }else if(state.filterOverrides.has(node._id)){
      const badge=ce('span','badge-override','Переопределено');
      const btn=ce('button','btn xs','Скрыть обратно');
      btn.addEventListener('click', ()=>{
        const id = node._id;
        withPreservedScroll(()=>{
          state.filterOverrides.delete(id);
          persistOverrides();
          renderModel();
        }, id);
      });
      content.appendChild(badge);
      content.appendChild(btn);
    }

    /* правая панель действий: [фильтрация] | [копирование] */
    const actions=ce('div','actions');

    const rowFilters = ce('div','row-filters');
    const showDisp = !!state.view.rowFilterDisplay;
    const showExp  = !!state.view.rowFilterExpand;

    const codeSvc = (node.nameEN||'').trim();
    const codeTyp = pickTypicalCodeForNode(node); // *_grp или nameEN

    if(showDisp){
      const svcInList = codeSvc && getServiceList().some(c=> normalize(c)===normalize(codeSvc));
      const svcOn = svcInList && state.filtersService[codeSvc]!==false;

      const bDisp = ce('button','fbtn','Отображение');
      if(!svcInList) bDisp.classList.add('dim');
      else if(svcOn) bDisp.classList.add('active');
      else bDisp.classList.add('dim');
      bDisp.dataset.kind='service';
      bDisp.dataset.code = codeSvc || '';
      bDisp.title = svcInList ? (svcOn?'В фильтре (включён)':'В фильтре (выключен)') : 'Не в фильтре';
      bDisp.addEventListener('click', (ev)=> openFilterMenu(ev.currentTarget, node, 'service', codeSvc));
      rowFilters.appendChild(bDisp);
    }

    if(showExp){
      const typInList = !!codeTyp && getTypicalList().some(c=> normalize(c)===normalize(codeTyp));
      const blockedByService = codeTyp && state.filtersService[codeTyp]===false;
      const bExp = ce('button','fbtn','Разворачивание');
      if(!typInList) bExp.classList.add('dim'); else bExp.classList.add('active');
      if(blockedByService) bExp.classList.add('blocked');
      bExp.dataset.kind='typical';
      bExp.dataset.code = codeTyp || '';
      bExp.title = blockedByService ? 'Отключено отображением (включите выше)'
                : typInList ? 'В фильтре разворачивания' : 'Не в фильтре';
      bExp.addEventListener('click', (ev)=> openFilterMenu(ev.currentTarget, node, 'typical', codeTyp, blockedByService));
      rowFilters.appendChild(bExp);
    }

    const sep = ce('span','sep','|');

    const copy=ce('div','copy');
    if(state.view.copyRU) copy.appendChild(mkCopyBtn('Имя', node.nameRU||'' ));
    if(state.view.copyPath) copy.appendChild(mkCopyBtn('Путь', xpathEN(node) ));
    if(state.view.copyEN) copy.appendChild(mkCopyBtn('Код', node.nameEN||'' ));

    actions.append(rowFilters, sep, copy);

    left.append(caret, dot, content);
    row.append(left, ce('div'), actions);
    els.tree.appendChild(row);

    const expandedNow = state.expanded.has(node._id);
    if(expandedNow && (node.children||[]).length){ node.children.forEach(ch=>renderNode(ch)); }

    /* события на caret/dot */
    caret.addEventListener('click', ()=>{
      if((node.children||[]).length || node._filteredCollapse){
        withPreservedScroll(()=>{
          if(state.expanded.has(node._id)) state.expanded.delete(node._id); else state.expanded.add(node._id);
          saveState();
          renderModel();
        }, node._id);
      }
    });
    dot.addEventListener('click', ()=> openCardAtRow(row, node));
  }

  renderNode(model);
  updateBadgesCounts();

  const statsModel = filteredTree();
  const maxDepthFull=statsModel ? maxDepthOf(statsModel) : 0;
  const rowsTotal=statsModel ? countNodes(statsModel) : 0;
  setMaxDepth(maxDepthFull);
  setRowsTotal(rowsTotal);

  const sliceActiveNow = isSliceActive();
  if(sliceActiveNow && pendingBefore){
    if(state.slice.anchorId) scrollToSliceAnchor(state.slice.anchorId);
    const code = (state.slice.anchorCode||'').trim();
    if(code) showToast(`Показана ветка: ${code}`);
  }
  if(missingAnchorMessage) showToast(missingAnchorMessage);
  if(sliceActiveNow){
    state.slicePendingReapply = false;
  }

  state.focusedIndex=Math.min(state.focusedIndex, Math.max(0, flat.length-1));
  focusRowByIndex(state.focusedIndex);

  state.tempShownRows.clear();
}

function matchCodeFromList(node, codes){
  const normName = normalize(node.nameEN);
  for(const code of codes){
    const normCode = normalize(code);
    if(node[code+'_grp'] || normCode===normName) return { code, normalized: normCode };
  }
  return null;
}

function pickTypicalCodeForNode(n){
  for(const k of getTypicalList()){ if(n[k+'_grp']) return k; }
  return (n.nameEN||'').trim();
}

function countHiddenRowsForFilteredNode(id){
  const orig = getByIdFull(id);
  if(!orig) return 0;
  return countDescendants(orig);
}

function filteredTree(applySlice=true){
  if(!state.modelRoot) return null;
  const base = deepClone(state.modelRoot);

  const afterTypical = applyTypicalGroupExpand(base, state.filtersTypical, state.filtersService);
  const afterService = filterService(afterTypical, state.filtersService, true);
  state.oneTimeInfo = computeOneTimeInfo(afterService);
  const afterSingle = applySingleRowVisibility(afterService);
  const afterOnce = applyOneTimeExpand(afterSingle);
  const pruned = pruneByExpanded(afterOnce);

  if(applySlice && isSliceActive()){
    return sliceTreeToAnchor(pruned);
  }
  return pruned;
}
function pruneByExpanded(root){
  function rec(n){
    const isExpanded = state.expanded.has(n._id) || n._id===root._id;
    const kids = isExpanded ? (n.children||[]).map(rec).filter(Boolean) : [];
    return {...n, children:kids};
  }
  return rec(root);
}
function sliceTreeToAnchor(root){
  const anchorId = state.slice.anchorId || '';
  const code = state.slice.anchorCode || '';
  const qn = state.slice.anchorQName || '';
  let anchor = anchorId ? findNodeInTreeById(root, anchorId) : null;
  if(!anchor && code) anchor = findNodeInTreeByName(root, code);
  if(!anchor && qn) anchor = findNodeInTreeByQName(root, qn);
  if(!anchor) return null;
  return deepClone(anchor);
}
function findNodeInTreeById(node, id){
  if(!node) return null;
  if(node._id===id) return node;
  for(const ch of node.children||[]){
    const found=findNodeInTreeById(ch,id);
    if(found) return found;
  }
  return null;
}
function findNodeInTreeByName(node, code){
  if(!node || !code) return null;
  const target=normalize(code);
  if(normalize(node.nameEN)===target) return node;
  for(const ch of node.children||[]){
    const found=findNodeInTreeByName(ch, code);
    if(found) return found;
  }
  return null;
}
function findNodeInTreeByQName(node, qn){
  if(!node || !qn) return null;
  const target=normalize(qn);
  if(normalize(node.qname)===target) return node;
  for(const ch of node.children||[]){
    const found=findNodeInTreeByQName(ch, qn);
    if(found) return found;
  }
  return null;
}

/* ========= Навигация, карточка ========= */
els.tree.addEventListener('click', (e)=>{
  const row=e.target.closest('.row'); if(!row) return;
  const id=row.dataset.id; const node=getByIdFull(id);

  if(e.ctrlKey && (node.children||[]).length){
    withPreservedScroll(()=>{
      expandAllRecursive(node); saveState(); renderModel();
    }, id);
  } else if((node.children||[]).length){
    withPreservedScroll(()=>{
      if(state.expanded.has(id)) state.expanded.delete(id);
      saveState(); state.expanded.add(id); renderModel();
    }, id);
  }
});

document.addEventListener('keydown',(e)=>{
  if(els.reportDlg.open || els.typicalCfgDlg.open || els.serviceCfgDlg.open) return;
  const rows=Array.from(els.tree.querySelectorAll('.row:not([hidden])')); if(!rows.length) return;
  const cur=rows[state.focusedIndex] || rows[0];

  if(e.key==='ArrowDown'){ e.preventDefault(); state.focusedIndex=Math.min(state.focusedIndex+1, rows.length-1); focusRowByIndex(state.focusedIndex); }
  else if(e.key==='ArrowUp'){ e.preventDefault(); state.focusedIndex=Math.max(state.focusedIndex-1, 0); focusRowByIndex(state.focusedIndex); }
  else if(e.key==='ArrowRight'){ e.preventDefault(); const id=cur.dataset.id; const n=getByIdFull(id); if(n&&((n.children||[]).length||n._filteredCollapse)&&!state.expanded.has(id)){ withPreservedScroll(()=>{ state.expanded.add(id); saveState(); renderModel(); }, id); } }
  else if(e.key==='ArrowLeft'){ e.preventDefault(); const id=cur.dataset.id; if(state.expanded.has(id)){ withPreservedScroll(()=>{ state.expanded.delete(id); saveState(); renderModel(); }, id); } }
  else if(e.key==='Enter'){ e.preventDefault(); const id=cur.dataset.id; const n=getByIdFull(id); const dot=cur.getBoundingClientRect(); openCardAtPosition(n, dot.left+20, dot.top+16); }
  else if(e.key==='Escape'){ closeCard(); hideFilterMenu(); }
});

function focusRowByIndex(i){
  const rows=Array.from(els.tree.querySelectorAll('.row:not([hidden])'));
  rows.forEach(r=>r.setAttribute('aria-selected','false'));
  const row=rows[i]; if(!row) return;
  row.setAttribute('aria-selected','true');
  if(!suppressFocusScroll) row.scrollIntoView({block:'nearest', inline:'nearest'});
}

/* Карточка */
const cardEl=q('#card');
const c_ru=q('#c_ru'), c_en=q('#c_en'), c_qn=q('#c_qn'), c_path=q('#c_path'),
      c_type=q('#c_type .type-link'), c_attrs=q('#c_attrs'), c_facets=q('#c_facets'),
      c_flags=q('#c_flags'), c_req=q('#c_req .req');

q('#cardClose').addEventListener('click', closeCard);
document.addEventListener('click', (e)=>{ if(cardEl.style.display==='none') return; if(e.target.closest('#card') || e.target.classList.contains('dot')) return; closeCard(); });

$$('#card [data-copy]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const kind=btn.getAttribute('data-copy');
    if(kind==='ru') copyToClipboard(c_ru.textContent||'');
    if(kind==='en') copyToClipboard((c_en.textContent||'').trim());
    if(kind==='xpath') copyToClipboard((c_path.textContent||'').trim());
    showToast('Скопировано');
  });
});

function openCardAtRow(row, node){ const r=row.querySelector('.dot').getBoundingClientRect(); openCardAtPosition(node, r.left+4, r.top+16); }
function openCardAtPosition(node, x, y){
  c_ru.textContent=node.nameRU||''; c_en.textContent=node.nameEN||''; c_qn.textContent=node.qname||''; c_path.textContent=xpathEN(node);
  c_type.textContent=node.type||''; c_type.onclick=()=>highlightType(node.type||'');
  const r=node.req||'optional'; c_req.textContent=r==='required'?'Обяз.':(r==='conditional'?'Условно':'Необяз.'); c_req.className='req req-'+r;
  c_attrs.innerHTML='<span class="hint">—</span>'; c_facets.innerHTML='<span class="hint">—</span>';

  const flags=[];
  if(node.signable && !node.signature && !node.keyInfo) flags.push('signable');
  if(node.wrapper) flags.push('wrapper');
  if(node.signature) flags.push('signature');
  if(node.keyInfo) flags.push('keyInfo');
  if(node.annotation) flags.push('annotation');
  if(node.documentation) flags.push('documentation');
  if(node.object) flags.push('object');

  getTypicalList().forEach(code=>{ if(node[code]) flags.push(humanTitleForCode(code)+'('+code+')'); });
  getServiceList().forEach(code=>{ if(node[code]) flags.push(code); });
  if(node.idBusiness) flags.push('id(business)');
  if(node.idXml) flags.push('id(xml)');
  if(node.dateTime) flags.push('dateTime');
  if(node.guid) flags.push('guid');
  if(node.schemaVersion) flags.push('schemaVersion');
  if(node.hasAssert) flags.push('assert');

  c_flags.textContent=flags.length? flags.join(', ') : '—';

  cardEl.style.display='block';
  const cw=cardEl.offsetWidth, ch=cardEl.offsetHeight, pad=10;
  cardEl.style.left=Math.min(Math.max(x,pad), window.innerWidth-cw-pad)+'px';
  cardEl.style.top =Math.min(Math.max(y,pad), window.innerHeight-ch-pad)+'px';
}
function closeCard(){ cardEl.style.display='none' }
function highlightType(tp){
  if(!tp) return;
  $$('.row').forEach(r=>{ r.style.outline=(r.dataset.type||'')===tp?'2px dashed #7bc9b1':'none'; });
  showToast('Подсветка типа: '+tp);
}

/* ========= Контекстное меню фильтра-кнопок ========= */
let fltMenuState = { open:false, kind:null, code:'', anchor:null, nodeId:null, extra:null };

function showContextMenu(state, build){
  const menu = els.fltMenu;
  if(!menu) return;
  if(fltMenuState.open) hideFilterMenu();
  const anchor = state?.anchor;
  if(!anchor){
    fltMenuState = { open:false, kind:null, code:'', anchor:null, nodeId:null, extra:null };
    return;
  }
  fltMenuState = {
    open:true,
    kind: state.kind||null,
    code: state.code||'',
    anchor,
    nodeId: state.nodeId||null,
    extra: state.extra||null
  };

  menu.innerHTML='';
  build(menu);
  if(!menu.children.length){
    hideFilterMenu();
    return;
  }

  menu.style.display='block';

  function positionMenu(){
    const anchorEl = fltMenuState.anchor;
    if(!anchorEl || !document.contains(anchorEl)){
      hideFilterMenu();
      return;
    }
    const r = anchorEl.getBoundingClientRect();
    const maxLeft = window.innerWidth - 360;
    const x = window.scrollX + Math.min(Math.max(0, r.left), Math.max(0, maxLeft));
    const y = window.scrollY + r.bottom + 6;
    menu.style.left = x + 'px';
    menu.style.top  = y + 'px';
  }

  positionMenu();
  _onScrollReposition = () => positionMenu();
  _addMenuRepositioners(_onScrollReposition);

  setTimeout(()=> {
    document.addEventListener('mousedown', onDocDown, true);
    document.addEventListener('keydown', onEsc, true);
  },0);
}

function openFilterMenu(btn, node, kind, code, blocked=false){
  if(kind==='typical' && (!code || !code.trim())) code = (node.nameEN||'').trim();
  if((kind==='service' || kind==='typical') && (!code || !code.trim())){
    showToast('Нет кода для операции');
    return;
  }

  const normalizedCode = normalize(code||'');
  const title = humanTitleForCode(code) || code;

  showContextMenu({ kind, code, anchor:btn, nodeId: node._id, extra:{ blocked } }, (menu)=>{
    if(kind==='service'){
      const rowKeyNorm = normalizeRowKeyInput(rowKeyFor(node));
      const canHideSingle = rowKeyNorm && depthOf(node)>0;
      if(canHideSingle){
        if(!(state.hideRows instanceof Map)) state.hideRows = normalizeHideRowsMap(state.hideRows);
        const hasEntry = state.hideRows.has(rowKeyNorm);
        const currentlyHidden = hasEntry ? state.hideRows.get(rowKeyNorm)!==false : false;
        if(currentlyHidden){
          menu.appendChild(mi('Показать строку', ()=> withPreservedScroll(()=>{
            state.hideRows.set(rowKeyNorm, false);
            persistHideRows();
            renderModel();
          }, node._id)));
        }else{
          menu.appendChild(mi(hasEntry ? 'Скрыть строку' : 'Скрыть только строку', ()=> withPreservedScroll(()=>{
            state.hideRows.set(rowKeyNorm, true);
            persistHideRows();
            renderModel();
          }, node._id)));
        }
      }else{
        menu.appendChild(mi('Скрыть только строку недоступно для корневого узла', null, true));
      }

      const svcInList = getServiceList().some(c=> normalize(c)===normalizedCode);
      const svcOn = svcInList && state.filtersService[code]!==false;

      if(!svcInList){
        menu.appendChild(mi(`Добавить в «Отображение» (${title})`, ()=> withPreservedScroll(()=>{
          addCodeToServiceList(code, true);
          showToast('Добавлено в «Отображение»');
          renderModel();
        }, node._id)));
      }else{
          menu.appendChild(mi('Удалить из «Отображение»', ()=> withPreservedScroll(()=>{
            removeCodeFromServiceList(code);
            showToast('Удалено из «Отображение»');
            renderModel();
        }, node._id)));
        if(svcOn){
          menu.appendChild(mi('Выключить отображение (снять чекбокс)', ()=> withPreservedScroll(()=>{
            toggleServiceCheckbox(code,false);
            showToast('Отображение выключено');
            renderModel();
          }, node._id)));
        }else{
          menu.appendChild(mi('Включить отображение (поставить чекбокс)', ()=> withPreservedScroll(()=>{
            toggleServiceCheckbox(code,true);
            showToast('Отображение включено');
            renderModel();
          }, node._id)));
        }
      }
    }else if(kind==='typical'){
      const typInList = getTypicalList().some(c=> normalize(c)===normalizedCode);
      const typOn = typInList && state.filtersTypical[code]!==false;
      const effectiveOneTimeCode = node._oneTimeCode || code || '';
      const blockedByService = state.filtersService[code]===false || state.filtersService[effectiveOneTimeCode]===false;
      const isBlocked = !!blocked;

      if(isBlocked){
        menu.appendChild(mi('Недоступно: отключено в «Отображение»', null, true));
      }else if(!typInList){
        menu.appendChild(mi(`Добавить в «Разворачивание» (${title})`, ()=> withPreservedScroll(()=>{
          addCodeToTypicalList(code, true);
          showToast('Добавлено в «Разворачивание»');
          renderModel();
        }, node._id)));
      }else{
        menu.appendChild(mi('Удалить из «Разворачивания»', ()=> withPreservedScroll(()=>{
          removeCodeFromTypicalList(code);
          showToast('Удалено из «Разворачивания»');
          renderModel();
        }, node._id)));
        if(typOn){
          menu.appendChild(mi('Выключить разворачивание (снять чекбокс)', ()=> withPreservedScroll(()=>{
            toggleTypicalCheckbox(code,false);
            showToast('Разворачивание выключено');
            renderModel();
          }, node._id)));
        }else{
          menu.appendChild(mi('Включить разворачивание (поставить чекбокс)', ()=> withPreservedScroll(()=>{
            toggleTypicalCheckbox(code,true);
            showToast('Разворачивание включено');
            renderModel();
          }, node._id)));
        }
        if(blockedByService){
          menu.appendChild(mi('Отключено отображением (включите выше)', null, true));
        }
      }

      const onceCounts = state.oneTimeInfo?.counts || new Map();
      const onceFirsts = state.oneTimeInfo?.firsts || new Map();
      const normalizedOneTimeCode = normalize(effectiveOneTimeCode);
      const inOneTime = effectiveOneTimeCode ? getOneTimeList().some(c=> normalize(c)===normalizedOneTimeCode) : false;
      const onceActive = inOneTime ? state.filtersTypicalOnce[effectiveOneTimeCode]!==false : false;
      const firstId = node._oneTimeFirstId || onceFirsts.get(normalizedOneTimeCode) || '';
      const totalOccurrences = (normalizedOneTimeCode ? (onceCounts.get(normalizedOneTimeCode) || 0) : (onceCounts.get(normalizedCode) || 0));
      const hasOverride = state.filterOverrides.has(node._id);
      const isHidden = !!node._oneTimeHidden;

      if(inOneTime){
        const showOnceDisabled = !onceActive || blockedByService || !isHidden;
        menu.appendChild(mi('Показать только один раз (локально)', showOnceDisabled ? null : ()=> withPreservedScroll(()=>{
          state.filterOverrides.add(node._id);
          persistOverrides();
          renderModel();
        }, node._id), showOnceDisabled));
        if(hasOverride){
          menu.appendChild(mi('Снять локальное отображение', ()=> withPreservedScroll(()=>{
            state.filterOverrides.delete(node._id);
            persistOverrides();
            renderModel();
          }, node._id)));
        }
        menu.appendChild(mi('Снять “однократно” для кода', ()=> withPreservedScroll(()=>{
          removeCodeFromOneTimeList(effectiveOneTimeCode);
          showToast('Код исключён из «однократного»');
          renderModel();
        }, node._id)));
        if(totalOccurrences>=2 && firstId && firstId!==node._id){
          menu.appendChild(mi('Перейти к первой встрече', ()=> jumpToFirstOccurrence(firstId, effectiveOneTimeCode)));
        }
      }else if(totalOccurrences>=2){
        menu.appendChild(mi('Включить “однократно” для кода', ()=> withPreservedScroll(()=>{
          addCodeToOneTimeList(effectiveOneTimeCode, true);
          showToast('Код добавлен в «однократное»');
          renderModel();
        }, node._id)));
      }
    }
  });
}

function openHiddenParentMenu(anchor, node){
  const label = node._parentHiddenLabel || {};
  const parentKey = normalizeRowKeyInput(label.key || '');
  showContextMenu({ kind:'hidden-parent', code:'', anchor, nodeId: node._id, extra:{ parentKey } }, (menu)=>{
    if(!parentKey){
      menu.appendChild(mi('Не удалось определить скрытого родителя', null, true));
      return;
    }
    menu.appendChild(mi('Удалить родителя из “Отображения одной строки”', ()=> withPreservedScroll(()=>{
      if(!(state.hideRows instanceof Map)) state.hideRows = normalizeHideRowsMap(state.hideRows);
      state.hideRows.delete(parentKey);
      persistHideRows();
      renderModel();
    }, node._id)));
    menu.appendChild(mi('Показать временно родителя', ()=>{
      showHiddenRowTemporarily(parentKey, { scroll:true });
    }));
  });
}

function openSingleRowInfoMenu(anchor, info){
  const normalizedKey = normalizeRowKeyInput(info.key || '');
  const titleParts = [];
  const name = (info.name||'').trim();
  const code = (info.code||'').trim();
  if(name && code){ titleParts.push(`${name} (${code})`); }
  else if(name){ titleParts.push(name); }
  else if(code){ titleParts.push(code); }
  else if(normalizedKey){ titleParts.push(normalizedKey); }

  const statusText = info.status === 'missing' ? 'Не найдено' : 'Найдено';
  const keyPath = normalizedKey.split('|').slice(1).join('|');
  const pathSource = info.path || keyPath;
  const pathLabel = formatRowPathLabel(pathSource);

  showContextMenu({ kind:'single-info', code:info.code||'', anchor, nodeId:null, extra:{ key: normalizedKey } }, (menu)=>{
    const box=document.createElement('div');
    box.className='mi-info';
    const titleEl=document.createElement('strong');
    titleEl.textContent= titleParts.join('') || 'Строка';
    box.appendChild(titleEl);
    const meta=document.createElement('div');
    meta.className='mi-info-meta';
    meta.innerHTML = `<span>Статус: ${escapeHtml(statusText)}</span><span>Путь: ${escapeHtml(pathLabel)}</span><span>Ключ: ${escapeHtml(normalizedKey)}</span>`;
    box.appendChild(meta);
    menu.appendChild(box);

    const actions=document.createElement('div');
    actions.className='mi-actions';
    const btnGo=ce('button','btn micro','Перейти');
    const btnTemp=ce('button','btn micro','Показать временно');
    btnGo.addEventListener('click', ()=>{ hideFilterMenu(); showHiddenRowTemporarily(normalizedKey, { scroll:true }); });
    btnTemp.addEventListener('click', ()=>{ hideFilterMenu(); showHiddenRowTemporarily(normalizedKey, { scroll:false }); });
    if(info.status==='missing' || !normalizedKey){
      btnGo.disabled = true;
      btnTemp.disabled = true;
    }
    actions.append(btnGo, btnTemp);
    menu.appendChild(actions);
  });
}

function hideFilterMenu(){
  els.fltMenu.style.display='none';
  fltMenuState = { open:false, kind:null, code:'', anchor:null, nodeId:null, extra:null };
  document.removeEventListener('mousedown', onDocDown, true);
  document.removeEventListener('keydown', onEsc, true);
  if (_onScrollReposition){
    _removeMenuRepositioners(_onScrollReposition);
    _onScrollReposition = null;
  }
}


function mi(text, fn, disabled=false){
  const d=ce('div','mi',text);
  if(disabled){ d.setAttribute('aria-disabled','true'); }
  else { d.addEventListener('click', ()=>{ hideFilterMenu(); fn && fn(); }); }
  return d;
}

/* Операции с код-листами/чекбоксами */
function addCodeToServiceList(code, turnOn=true){
  if(!code) return;
  const list = new Set(getServiceList()); list.add(code);
  saveServiceAllCodes(Array.from(list));
  ensureServiceFilterFlags();
  state.filtersService[code] = !!turnOn;
  localStorage.setItem(LS_FILTER_SERVICE, JSON.stringify(state.filtersService));
  reindexFlagsAll();
}
function removeCodeFromServiceList(code){
  const list = getServiceList().filter(x=> normalize(x)!==normalize(code));
  saveServiceAllCodes(list);
  ensureServiceFilterFlags();
  delete state.filtersService[code];
  localStorage.setItem(LS_FILTER_SERVICE, JSON.stringify(state.filtersService));
  reindexFlagsAll();
}
function toggleServiceCheckbox(code,on){
  ensureServiceFilterFlags();
  if(!(code in state.filtersService)) state.filtersService[code]=true;
  state.filtersService[code]=!!on;
  localStorage.setItem(LS_FILTER_SERVICE, JSON.stringify(state.filtersService));
}

function addCodeToTypicalList(code, turnOn=true){
  if(!code) return;
  const list = new Set(getTypicalList()); list.add(code);
  state.typicalCodes = Array.from(list);
  saveTypicalCodes(state.typicalCodes);
  ensureTypicalFilterFlags();
  state.filtersTypical[code] = !!turnOn;
  localStorage.setItem(LS_FILTER_TYPICAL, JSON.stringify(state.filtersTypical));
  reindexFlagsAll();
}
function removeCodeFromTypicalList(code){
  state.typicalCodes = getTypicalList().filter(x=> normalize(x)!==normalize(code));
  saveTypicalCodes(state.typicalCodes);
  ensureTypicalFilterFlags();
  delete state.filtersTypical[code];
  localStorage.setItem(LS_FILTER_TYPICAL, JSON.stringify(state.filtersTypical));
  reindexFlagsAll();
}
function toggleTypicalCheckbox(code,on){
  ensureTypicalFilterFlags();
  if(!(code in state.filtersTypical)) state.filtersTypical[code]=true;
  state.filtersTypical[code]=!!on;
  localStorage.setItem(LS_FILTER_TYPICAL, JSON.stringify(state.filtersTypical));
}

function addCodeToOneTimeList(code, turnOn=true){
  if(!code) return;
  const list = new Set(getOneTimeList()); list.add(code);
  state.typicalOnceCodes = Array.from(list);
  saveTypicalOnceCodes(state.typicalOnceCodes);
  ensureTypicalOnceFilterFlags();
  state.filtersTypicalOnce[code] = !!turnOn;
  localStorage.setItem(LS_FILTER_TYPICAL_ONCE, JSON.stringify(state.filtersTypicalOnce));
  reindexFlagsAll();
}
function removeCodeFromOneTimeList(code){
  state.typicalOnceCodes = getOneTimeList().filter(x=> normalize(x)!==normalize(code));
  saveTypicalOnceCodes(state.typicalOnceCodes);
  ensureTypicalOnceFilterFlags();
  delete state.filtersTypicalOnce[code];
  localStorage.setItem(LS_FILTER_TYPICAL_ONCE, JSON.stringify(state.filtersTypicalOnce));
  reindexFlagsAll();
}
function toggleOneTimeCheckbox(code,on){
  ensureTypicalOnceFilterFlags();
  if(!(code in state.filtersTypicalOnce)) state.filtersTypicalOnce[code]=true;
  state.filtersTypicalOnce[code]=!!on;
  localStorage.setItem(LS_FILTER_TYPICAL_ONCE, JSON.stringify(state.filtersTypicalOnce));
}

/* ========= Отчёт ========= */
q('#reportBtn').addEventListener('click', ()=>{
  const body=q('#reportBody');
  if(!state.repo){
    body.innerHTML=`<p class="hint">Загрузите XSD, чтобы сформировать отчёт.</p>`;
  }else{
    const files=(state.repo.docs||[]).map(d=>d.name);
    const model=filteredTree();
    const stats=model? computeStats(model) : {total:0,maxDepth:0};
    const unresolved=state.repo.unresolvedImports||[];
    const sliceActive=isSliceActive();
    const anchorMethod=sliceActive ? 'code' : '—';
    const anchorCode =sliceActive ? (state.slice?.anchorCode || '—') : '—';
    const anchorQName=sliceActive ? (state.slice?.anchorQName || '—') : '—';
    const anchorPath =sliceActive ? (state.slice?.anchorPath || '—') : '—';
    const overridesCount = state.filterOverrides.size;

    body.innerHTML = `
      <table>
        <tr><th>Файлы</th><td>${escapeHtml(files.join(', ')) || '—'}</td></tr>
        <tr><th>Глобальные элементы</th><td>${state.repo.elements.size}</td></tr>
        <tr><th>Типы (complex+simple)</th><td>${state.repo.types.size}</td></tr>
        <tr><th>Всего видимых узлов</th><td>${stats.total}</td></tr>
        <tr><th>Макс. глубина (видимая)</th><td>${stats.maxDepth}</td></tr>
        <tr><th>Срез</th><td>${anchorMethod}; код: ${escapeHtml(anchorCode)}; QName: ${escapeHtml(anchorQName)}; XPath: ${escapeHtml(anchorPath)}</td></tr>
        <tr><th>Неразрешённые импорты</th><td>${unresolved.length}</td></tr>
        <tr><th>XML-ID / Бизнес-ID</th><td>id(xml): ${buildDiagnostics.idXmlCount}; id(business): ${buildDiagnostics.idBusinessCount}</td></tr>
        <tr><th>Локальные переопр. фильтра</th><td>${overridesCount}</td></tr>
      </table>
    `;
  }
  q('#reportDlg').showModal();
});
q('#reportClose').addEventListener('click', ()=> q('#reportDlg').close());

function computeStats(root){
  const st={total:0,maxDepth:0};
  walk(root, n=>{ st.total++; const d=depthOf(n); if(d>st.maxDepth) st.maxDepth=d; });
  return st;
}

/* ========= Экспорт/импорт ========= */
function handleDownloadAction(kind){
  if(kind==='txt'){
    const lines=[];
    const rows = Array.from(document.querySelectorAll('#tree .row'));
    if(!rows.length){ showToast('Нет данных для экспорта'); return; }
    for(const r of rows){
      if(r.hasAttribute('hidden')) continue;
      const id = r.dataset.id;
      const n  = getByIdFull(id);
      if(!n) continue;
      const depth = depthOf(n);
      const pad='  '.repeat(Math.max(0,depth));
      const parts=[];
      const hasRU = !!(n.nameRU && n.nameRU.trim());
      if(state.view.showRU && hasRU) parts.push(n.nameRU);
      if(state.view.showEN && n.nameEN) parts.push(`[${n.nameEN}]`);
      if(state.view.showType && n.type) parts.push(`<${n.type}>`);
      if(state.view.showReq && n.req) parts.push(n.req==='required'?'(обяз.)':(n.req==='conditional'?'(условно)':'(необяз.)'));
      lines.push(pad+parts.join(' '));
    }
    const txt=lines.join('\n');
    const name = `${exportBaseName()}__${ts_hyphen()}.txt`;
    downloadBlob(name, new Blob([txt], {type:'text/plain;charset=utf-8'}));
  }else if(kind==='snap-save'){
    const payload = {
      view: state.view,
      filtersService: state.filtersService,
      filtersTypical: state.filtersTypical,
      filtersTypicalOnce: state.filtersTypicalOnce,
      expandLevel: state.expandLevel,
      expanded: Array.from(state.expanded),
      slice: state.slice,
      typicalCodes: state.typicalCodes,
      typicalOnceCodes: state.typicalOnceCodes,
      serviceAllCodes: state.serviceAllCodes,
      treeCompact: !!state.treeCompact,
      overrides: Array.from(state.filterOverrides),
      hideRows: serializeHideRowsState()
    };
    downloadBlob(`xsdv-snapshot-${ts_hyphen()}.json`, new Blob([JSON.stringify(payload,null,2)], {type:'application/json'}));
  }else if(kind==='snap-load'){
    q('#snapFile').click();
  }else if(kind==='settings-export'){
    exportSettings();
  }else if(kind==='settings-import'){
    q('#settingsFile').click();
  }
}
q('#snapFile').addEventListener('change', async ()=>{
  const f=q('#snapFile').files[0]; if(!f) return;
  try{
    const json=JSON.parse(await f.text());
    applyImportedSettings(json);
    showToast('Snapshot загружен');
  }catch(e){ console.error(e); showToast('Ошибка загрузки snapshot'); }
});

function exportSettings(){
  const settings={
    schema:'xsdv-settings-v2',
    view: state.view,
    filtersService: state.filtersService,
    filtersTypical: state.filtersTypical,
    filtersTypicalOnce: state.filtersTypicalOnce,
    expandLevel: state.expandLevel,
    expanded: Array.from(state.expanded),
    slice: state.slice,
    typicalCodes: state.typicalCodes,
    typicalOnceCodes: state.typicalOnceCodes,
    serviceAllCodes: state.serviceAllCodes,
    treeCompact: !!state.treeCompact,
    overrides: Array.from(state.filterOverrides),
    hideRows: serializeHideRowsState()
  };
  downloadBlob(`XSDV_Настройки__${ts_hyphen()}.json`, new Blob([JSON.stringify(settings,null,2)], {type:'application/json'}));
}
q('#settingsFile').addEventListener('change', async ()=>{
  const f=q('#settingsFile').files[0]; if(!f) return;
  try{
    const json=JSON.parse(await f.text());
    if(json.schema!=='xsdv-settings-v2' && json.schema!=='xsdv-settings-v1'){ showToast('Неверный формат настроек'); return; }
    applyImportedSettings(json);
    showToast('Настройки применены');
  }catch(e){ console.error(e); showToast('Ошибка импорта настроек'); }
});
function applyImportedSettings(s){
  if(s.view) { state.view=s.view; localStorage.setItem(LS_VIEW, JSON.stringify(state.view)); restoreViewCheckboxes(); }
  if(s.filtersService){ state.filtersService=s.filtersService; localStorage.setItem(LS_FILTER_SERVICE, JSON.stringify(state.filtersService)); }
  if(s.filtersTypical){
    state.filtersTypical=s.filtersTypical;
    localStorage.setItem(LS_FILTER_TYPICAL, JSON.stringify(state.filtersTypical));
  }else if(s.filters){
    state.filtersService={...s.filters};
    state.filtersTypical={...s.filters};
    localStorage.setItem(LS_FILTER_SERVICE, JSON.stringify(state.filtersService));
    localStorage.setItem(LS_FILTER_TYPICAL, JSON.stringify(state.filtersTypical));
  }
  if(s.filtersTypicalOnce){
    state.filtersTypicalOnce=s.filtersTypicalOnce;
    localStorage.setItem(LS_FILTER_TYPICAL_ONCE, JSON.stringify(state.filtersTypicalOnce));
  }
  if(s.expandLevel){ state.expandLevel=s.expandLevel; localStorage.setItem(LS_LEVEL, state.expandLevel); elsAutoDepth.value=String(state.expandLevel); }
  if(Array.isArray(s.expanded)) { state.expanded=new Set(s.expanded); localStorage.setItem(LS_EXP, JSON.stringify(s.expanded)); }
  if(s.slice) {
    state.slice = normalizeSliceState(s.slice);
    state.slicePendingReapply = state.slice.method==='code';
    persistSliceState();
    syncSliceControls();
  }
  if(Array.isArray(s.typicalCodes)) { state.typicalCodes=s.typicalCodes; saveTypicalCodes(state.typicalCodes); }
  if(Array.isArray(s.typicalOnceCodes)) { state.typicalOnceCodes=s.typicalOnceCodes; saveTypicalOnceCodes(state.typicalOnceCodes); }
  if(Array.isArray(s.serviceAllCodes)) { saveServiceAllCodes(s.serviceAllCodes); }
  if(s.hideRows){
    state.hideRows = normalizeHideRowsMap(s.hideRows);
    persistHideRows();
  }
  if(typeof s.treeCompact==='boolean'){ state.treeCompact=s.treeCompact; localStorage.setItem(LS_TREE_COMPACT, String(state.treeCompact)); applyTreeCompact(); }
  if(Array.isArray(s.overrides)){ state.filterOverrides=new Set(s.overrides); persistOverrides(); }
  rebuildAfterConfigChange();
}

/* ========= Настройки списков ========= */
q('#cfgTypicalBtn').addEventListener('click', ()=>{
  els.typicalCodesArea.value = getTypicalList().join(', ');
  els.typicalCfgDlg.showModal();
});
q('#typicalCfgCancel').addEventListener('click', ()=> els.typicalCfgDlg.close());
q('#typicalLoadTxt').addEventListener('click', ()=> q('#typicalTxtFile').click());
q('#typicalTxtFile').addEventListener('change', async (e)=>{
  const f=e.target.files[0]; if(!f) return;
  els.typicalCodesArea.value = await f.text();
});
q('#typicalExportTxt').addEventListener('click', ()=>{
  const content=(els.typicalCodesArea.value||'').trim() || getTypicalList().join(', ');
  downloadBlob(`Типовые_фильтры__${ts_hyphen()}.txt`, new Blob([content], {type:'text/plain;charset=utf-8'}));
});
q('#typicalCfgApply').addEventListener('click', ()=>{
  const raw = els.typicalCodesArea.value||'';
  const codes = raw.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
  state.typicalCodes = Array.from(new Set(codes));
  saveTypicalCodes(state.typicalCodes);

  ensureTypicalFilterFlags();
  reindexFlagsAll();
  rebuildAfterConfigChange();

  els.typicalCfgDlg.close();
  showToast('Типовые фильтры обновлены');
});

els.cfgTypicalOnceBtn.addEventListener('click', ()=>{
  els.typicalOnceCodesArea.value = getOneTimeList().join(', ');
  els.typicalOnceCfgDlg.showModal();
});
els.typicalOnceCfgCancel.addEventListener('click', ()=> els.typicalOnceCfgDlg.close());
els.typicalOnceImportBtn.addEventListener('click', ()=> els.typicalOnceImportFile.click());
els.typicalOnceImportFile.addEventListener('change', async (e)=>{
  const f=e.target.files[0]; if(!f) return;
  els.typicalOnceCodesArea.value = await f.text();
});
els.typicalOnceExportBtn.addEventListener('click', ()=>{
  const content=(els.typicalOnceCodesArea.value||'').trim() || getOneTimeList().join(', ');
  downloadBlob(`Однократное_разворачивание__${ts_hyphen()}.txt`, new Blob([content], {type:'text/plain;charset=utf-8'}));
});
els.typicalOnceCfgApply.addEventListener('click', ()=>{
  const raw = els.typicalOnceCodesArea.value||'';
  const codes = raw.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
  state.typicalOnceCodes = Array.from(new Set(codes));
  saveTypicalOnceCodes(state.typicalOnceCodes);

  ensureTypicalOnceFilterFlags();
  reindexFlagsAll();
  rebuildAfterConfigChange();

  els.typicalOnceCfgDlg.close();
  showToast('Настройки «однократного» обновлены');
});

q('#cfgServiceBtn').addEventListener('click', ()=>{
  els.serviceCodesArea.value = getServiceList().join(', ');
  els.serviceCfgDlg.showModal();
});
q('#serviceCfgCancel').addEventListener('click', ()=> els.serviceCfgDlg.close());
q('#serviceLoadTxt').addEventListener('click', ()=> q('#serviceTxtFile').click());
q('#serviceTxtFile').addEventListener('change', async (e)=>{
  const f=e.target.files[0]; if(!f) return;
  els.serviceCodesArea.value = await f.text();
});
q('#serviceExportTxt').addEventListener('click', ()=>{
  const content=(els.serviceCodesArea.value||'').trim() || getServiceList().join(', ');
  downloadBlob(`Фильтры_отображения__${ts_hyphen()}.txt`, new Blob([content], {type:'text/plain;charset=utf-8'}));
});
q('#serviceCfgApply').addEventListener('click', ()=>{
  const raw = els.serviceCodesArea.value||'';
  const arr = raw.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
  saveServiceAllCodes(arr);

  ensureServiceFilterFlags();

  reindexFlagsAll();
  rebuildAfterConfigChange();

  els.serviceCfgDlg.close();
  showToast('Фильтры отображения обновлены');
});

els.cfgServiceSingleBtn.addEventListener('click', ()=>{
  const keys = state.hideRows instanceof Map ? Array.from(state.hideRows.keys()) : [];
  els.serviceSingleKeysArea.value = keys.join(', ');
  els.serviceSingleCfgDlg.showModal();
});
els.serviceSingleCfgCancel.addEventListener('click', ()=> els.serviceSingleCfgDlg.close());
els.serviceSingleImportBtn.addEventListener('click', ()=> els.serviceSingleImportFile.click());
els.serviceSingleImportFile.addEventListener('change', async (e)=>{
  const f=e.target.files[0]; if(!f) return;
  els.serviceSingleKeysArea.value = await f.text();
});
els.serviceSingleExportBtn.addEventListener('click', ()=>{
  const currentKeys = state.hideRows instanceof Map ? Array.from(state.hideRows.keys()) : [];
  const content=(els.serviceSingleKeysArea.value||'').trim() || currentKeys.join(', ');
  downloadBlob(`Отображение_одной_строки__${ts_hyphen()}.txt`, new Blob([content], {type:'text/plain;charset=utf-8'}));
});
els.serviceSingleCfgApply.addEventListener('click', ()=>{
  const raw = els.serviceSingleKeysArea.value||'';
  const payload = raw.split(/[\s,]+/).map(normalizeRowKeyInput).filter(Boolean);
  const uniqKeys = Array.from(new Set(payload));
  const next = new Map();
  const prev = state.hideRows instanceof Map ? state.hideRows : normalizeHideRowsMap(state.hideRows);
  uniqKeys.forEach(key=>{
    const prevHidden = prev.has(key) ? prev.get(key)!==false : true;
    next.set(key, prevHidden);
  });
  state.hideRows = next;
  persistHideRows();
  els.serviceSingleCfgDlg.close();
  rebuildAfterConfigChange();
  showToast('Список строк обновлён');
});

/* ========= Рендер чекбоксов ========= */
function ensureServiceFilterFlags(){
  const now = getServiceList();
  const cur = state.filtersService || {};
  Object.keys(cur).forEach(k=>{ if(!now.some(c=> normalize(c)===normalize(k))) delete cur[k]; });
  now.forEach(k=>{ if(!(k in cur)) cur[k]=true; });
  state.filtersService = cur;
  localStorage.setItem(LS_FILTER_SERVICE, JSON.stringify(state.filtersService));
}
function ensureTypicalFilterFlags(){
  const now = getTypicalList();
  const cur = state.filtersTypical || {};
  Object.keys(cur).forEach(k=>{ if(!now.some(c=> normalize(c)===normalize(k))) delete cur[k]; });
  now.forEach(k=>{ if(!(k in cur)) cur[k]=true; });
  state.filtersTypical = cur;
  localStorage.setItem(LS_FILTER_TYPICAL, JSON.stringify(state.filtersTypical));
}

function ensureTypicalOnceFilterFlags(){
  const now = getOneTimeList();
  const cur = state.filtersTypicalOnce || {};
  Object.keys(cur).forEach(k=>{ if(!now.some(c=> normalize(c)===normalize(k))) delete cur[k]; });
  now.forEach(k=>{ if(!(k in cur)) cur[k]=true; });
  state.filtersTypicalOnce = cur;
  localStorage.setItem(LS_FILTER_TYPICAL_ONCE, JSON.stringify(state.filtersTypicalOnce));
}

function buildServiceFilterCheckboxes(){
  ensureServiceFilterFlags();
  const row = els.serviceKeysRow;
  row.innerHTML='';
  const svcDtl=computeServiceCountsDetail();
  getServiceList().forEach(code=>{
    const wrap=document.createElement('div');
    const lbl = document.createElement('label'); lbl.className='cb-inline';
    const cb  = document.createElement('input'); cb.type='checkbox'; cb.setAttribute('data-filter-service', code);
    cb.checked = state.filtersService[code]!==false;
    cb.addEventListener('change', ()=>{
      state.filtersService[code]=cb.checked;
      saveFiltersToLS();
      withPreservedScroll(()=> renderModel());
    });
    const title = readableTitle(code);
    lbl.appendChild(cb);
    lbl.insertAdjacentText('beforeend', title);

    const badge=document.createElement('span'); badge.className='count-badge';
    const g = svcDtl[code]?.groups||0;
    const r = svcDtl[code]?.rows||0;
    if(cb.checked){
      badge.dataset.state='shown';
      badge.title=`Количество строк в составе: ${r}`;
    }else{
      badge.dataset.state='hidden';
      badge.title=`Скрыто групп: ${g}; Скрыто строк ≈ ${r}`;
    }
    badge.textContent= g;
    wrap.append(lbl, badge);
    row.appendChild(wrap);
  });
}
function buildTypicalFilterCheckboxes(){
  ensureTypicalFilterFlags();
  const row = els.typicalKeysRow; row.innerHTML='';
  const typDtl = computeTypicalCountsDetail();
  const serviceSet = new Set(getServiceList().map(normalize));

  getTypicalList().forEach(code=>{
    const wrap=document.createElement('div');
    const lbl = document.createElement('label'); lbl.className='cb-inline';
    const cb  = document.createElement('input'); cb.type='checkbox'; cb.setAttribute('data-filter-typical', code);

    const blockedByService = serviceSet.has(normalize(code)) && state.filtersService[code]===false;
    cb.checked = state.filtersTypical[code]!==false;
    cb.disabled = !!blockedByService;
    cb.addEventListener('change', ()=>{
      state.filtersTypical[code]=cb.checked;
      saveFiltersToLS();
      withPreservedScroll(()=> renderModel());
    });

    const title = readableTitle(code);
    lbl.appendChild(cb);
    lbl.insertAdjacentText('beforeend', title);
    if(blockedByService){
      lbl.classList.add('disabled-strike');
      lbl.title='Отключено в блоке «Отображение». Включите там, чтобы пользоваться разворачиванием.';
    }

    const badge=document.createElement('span'); badge.className='count-badge';
    const g = typDtl[code]?.groups||0;
    const r = typDtl[code]?.rows||0;
    if(cb.checked && !blockedByService){
      badge.dataset.state='shown';
      badge.title=`Количество строк в составе: ${r}`;
    }else{
      badge.dataset.state='hidden';
      badge.title=`Скрыто групп: ${g}; Скрыто строк ≈ ${r}`;
    }
    badge.textContent= g;
    wrap.append(lbl, badge);
    row.appendChild(wrap);
  });
}

function buildTypicalOnceFilterCheckboxes(){
  ensureTypicalOnceFilterFlags();
  const row = els.typicalOnceKeysRow; if(!row) return; row.innerHTML='';
  const onceDtl = computeTypicalOnceCountsDetail();
  const serviceSet = new Set(getServiceList().map(normalize));
  const fullSet = new Set(getTypicalList().map(normalize));

  getOneTimeList().forEach(code=>{
    const wrap=document.createElement('div');
    const lbl = document.createElement('label'); lbl.className='cb-inline';
    const cb  = document.createElement('input'); cb.type='checkbox'; cb.setAttribute('data-filter-typical-once', code);

    const blockedByService = serviceSet.has(normalize(code)) && state.filtersService[code]===false;
    cb.checked = state.filtersTypicalOnce[code]!==false;
    cb.disabled = !!blockedByService;
    cb.addEventListener('change', ()=>{
      state.filtersTypicalOnce[code]=cb.checked;
      saveFiltersToLS();
      withPreservedScroll(()=> renderModel());
    });

    const title = readableTitle(code);
    lbl.appendChild(cb);
    lbl.insertAdjacentText('beforeend', title);
    if(blockedByService){
      lbl.classList.add('disabled-strike');
      lbl.title='Отключено в блоке «Отображение». Включите отображение, чтобы использовать однократное разворачивание.';
    }

    const badge=document.createElement('span'); badge.className='count-badge';
    const g = onceDtl[code]?.groups||0;
    const r = onceDtl[code]?.rows||0;
    if(cb.checked && !blockedByService){
      badge.dataset.state='shown';
      badge.title=`Первая встреча раскрыта. Строк в ветке: ${r}`;
    }else{
      badge.dataset.state='hidden';
      badge.title=`Отключено. Групп: ${g}; Строк ≈ ${r}`;
    }
    badge.textContent= g;

    if(fullSet.has(normalize(code))){
      const note=document.createElement('span'); note.className='single-row-note';
      note.textContent='Код также в «вся ветка»';
      wrap.append(lbl, badge, note);
    }else{
      wrap.append(lbl, badge);
    }
    row.appendChild(wrap);
  });
}

function buildSingleRowList(){
  const listEl = els.singleRowList; if(!listEl) return;
  listEl.innerHTML='';
  const orphanEl = els.singleRowOrphans;
  if(orphanEl){ orphanEl.hidden=true; orphanEl.innerHTML=''; }

  if(!(state.hideRows instanceof Map)){
    state.hideRows = normalizeHideRowsMap(state.hideRows);
  }
  const entries = Array.from(state.hideRows.entries());
  if(!entries.length){
    listEl.appendChild(ce('div','hint','Список пуст. Используйте меню строки «Отображение → Скрыть только строку».'));
    return;
  }

  const missingEntries=[];

  entries.forEach(([key, hiddenFlag])=>{
    const info = resolveRowKey(key);
    const isHidden = hiddenFlag!==false;
    if(!info.node){
      missingEntries.push({ key, isHidden, info });
      return;
    }
    const node = info.node;
    const code = (node.nameEN||'').trim();
    const name = (node.nameRU||'').trim();
    const pathLabel = info.pathKey || node._pathKey || node._pathEN || '';
    const chip=document.createElement('label');
    chip.className='single-row-chip';
    chip.dataset.key = key;
    chip.dataset.state = isHidden ? 'hidden' : 'shown';
    chip.title = pathLabel;

    const checkbox=document.createElement('input');
    checkbox.type='checkbox';
    checkbox.className='single-row-chip-checkbox';
    checkbox.checked = !isHidden;
    checkbox.addEventListener('change', ()=>{
      state.hideRows.set(key, !checkbox.checked);
      persistHideRows();
      withPreservedScroll(()=> renderModel());
    });

    const content=document.createElement('div');
    content.className='single-row-chip-content';
    const title=ce('span','single-row-chip-title', name || code || key);
    content.appendChild(title);
    if(name && code){
      content.appendChild(ce('span','single-row-chip-sub', code));
    }else if(code && !name){
      content.appendChild(ce('span','single-row-chip-sub', code));
    }
    if(pathLabel){
      content.appendChild(ce('span','single-row-chip-sub', formatRowPathLabel(pathLabel)));
    }

    const marker=document.createElement('button');
    marker.type='button';
    marker.className='single-row-chip-marker';
    marker.textContent='•';
    marker.setAttribute('data-menu-anchor','true');
    marker.setAttribute('aria-label','Информация о скрытой строке');
    marker.title='Информация о скрытой строке';
    marker.addEventListener('click', (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      openSingleRowInfoMenu(ev.currentTarget, {
        key,
        name,
        code,
        path: pathLabel,
        status:'found'
      });
    });

    chip.append(checkbox, content, marker);
    listEl.appendChild(chip);
  });

  if(missingEntries.length && orphanEl){
    orphanEl.hidden=false;
    orphanEl.appendChild(ce('h4',null,'Не найдены в текущем дереве'));
    const ul=document.createElement('ul');
    missingEntries.forEach(item=>{
      const pathFromKey = item.key.split('|').slice(1).join('|');
      const chip=document.createElement('label');
      chip.className='single-row-chip';
      chip.dataset.key = item.key;
      chip.dataset.status='missing';
      chip.dataset.state = item.isHidden ? 'hidden' : 'shown';
      chip.title = pathFromKey;

      const checkbox=document.createElement('input');
      checkbox.type='checkbox';
      checkbox.className='single-row-chip-checkbox';
      checkbox.checked = !item.isHidden;
      checkbox.addEventListener('change', ()=>{
        state.hideRows.set(item.key, !checkbox.checked);
        persistHideRows();
        withPreservedScroll(()=> renderModel());
      });

      const content=document.createElement('div');
      content.className='single-row-chip-content';
      content.appendChild(ce('span','single-row-chip-title', item.key));
      if(pathFromKey){
        content.appendChild(ce('span','single-row-chip-sub', formatRowPathLabel(pathFromKey)));
      }

      const marker=document.createElement('button');
      marker.type='button';
      marker.className='single-row-chip-marker';
      marker.textContent='•';
      marker.setAttribute('data-menu-anchor','true');
      marker.setAttribute('aria-label','Информация о скрытой строке');
      marker.title='Информация о скрытой строке';
      marker.addEventListener('click', (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        openSingleRowInfoMenu(ev.currentTarget, {
          key: item.key,
          name:'',
          code:'',
          path:pathFromKey,
          status:'missing'
        });
      });

      chip.append(checkbox, content, marker);

      const li=document.createElement('li');
      li.appendChild(chip);
      ul.appendChild(li);
    });
    orphanEl.appendChild(ul);
  }
}

/* Подсчёты */
function computeServiceCountsDetail(){
  const keys=[...getServiceList()];
  const detail=Object.fromEntries(keys.map(k=>[k,{groups:0, rows:0}]));
  if(!state.modelRoot) return detail;
  walk(state.modelRoot, n=>{
    keys.forEach(k=>{
      if(nodeMatchesServiceCode(n,k)){
        detail[k].groups++;
        detail[k].rows += countDescendants(n);
      }
    });
  });
  return detail;
}
function computeTypicalCountsDetail(){
  const list=getTypicalList();
  const detail=Object.fromEntries(list.map(k=>[k,{groups:0, rows:0}]));
  if(!state.modelRoot) return detail;
  walk(state.modelRoot, n=>{
    list.forEach(k=>{
      if(n[k+'_grp'] || normalize(n.nameEN)===normalize(k)){
        detail[k].groups++;
        detail[k].rows += countDescendants(n);
      }
    });
  });
  return detail;
}

function computeTypicalOnceCountsDetail(){
  const list=getOneTimeList();
  const detail=Object.fromEntries(list.map(k=>[k,{groups:0, rows:0}]));
  if(!state.modelRoot) return detail;
  walk(state.modelRoot, n=>{
    list.forEach(k=>{
      if(n[k+'_grp'] || normalize(n.nameEN)===normalize(k)){
        detail[k].groups++;
        detail[k].rows += countDescendants(n);
      }
    });
  });
  return detail;
}

function computeOneTimeInfo(root){
  const codes = getOneTimeList();
  const normalizedList = new Set(codes.map(normalize));
  const firsts = new Map();
  const counts = new Map();
  if(!root) return { firsts, counts };
  walk(root, n=>{
    const codeRaw = (n.nameEN||'').trim();
    if(!codeRaw) return;
    const norm = normalize(codeRaw);
    counts.set(norm, (counts.get(norm) || 0) + 1);
    if(normalizedList.has(norm) && !firsts.has(norm)){
      firsts.set(norm, n._id);
    }
  });
  return { firsts, counts };
}

/* Титулы */
function readableTitle(code){
  const human = humanTitleForCode(code).trim();
  const normalizedCode = String(code).trim();
  if(!human || human.toLowerCase()===normalizedCode.toLowerCase()){
    return normalizedCode;
  }
  return `${human} (${normalizedCode})`;
}
function humanTitleForCode(code){
  if(!state.modelRoot) return prettifyTitle(code);
  let title='';
  walk(state.modelRoot, n=>{
    if(title) return;
    if(nodeMatchesServiceCode(n, code)) title=n.nameRU||'';
  });
  return title || prettifyTitle(code);
}
function prettifyTitle(code){
  return String(code)
    .replace(/[_\-]+/g,' ')
    .replace(/([a-z0-9])([A-Z])/g,'$1 $2')
    .trim()
    .replace(/^./, s=>s.toUpperCase());
}

/* ===================== Утилиты ===================== */
function q(s){ return document.querySelector(s) }
function $$(s){ return Array.from(document.querySelectorAll(s)) }
function ce(tag,cls,txt){ const e=document.createElement(tag); if(cls) e.className=cls; if(txt!=null) e.textContent=txt; return e }
function mkCopyBtn(label, text){ const b=ce('button','btn tiny',label); b.addEventListener('click',()=>{ copyToClipboard(text); showToast('Скопировано'); }); return b; }
function copyToClipboard(t){ navigator.clipboard?.writeText(t); }
function showToast(msg){ q('#toast').textContent=msg; q('#toast').style.display='block'; setTimeout(()=>{ q('#toast').style.display='none'; }, 1400); }
function showModalMessage(msg){ if(!els.infoModal){ alert(msg); return; } els.infoModalBody.textContent=msg; if(!els.infoModal.open) els.infoModal.showModal(); }
els.infoModalClose.addEventListener('click', ()=> els.infoModal.close());
function updateBadgesCounts(){
  const docs=state.repo?.docs?.length||0, ge=state.repo?.elements?.size||0, tp=state.repo?.types?.size||0;
  els.filesBadge.textContent='Файлов: '+docs; els.globalsBadge.textContent='Глоб. элементов: '+ge; els.typesBadge.textContent='Типов: '+tp;
}
function setMaxDepth(v){ els.maxDepthBadge.textContent='Максимальная глубина: '+v; }
function setRowsTotal(v){ els.rowsBadge.textContent='Строк всего: '+v; }
function maxDepthOf(root){ let m=0; walk(root, n=>{ const d=depthOf(n); if(d>m) m=d; }); return m; }
function countNodes(root){ let c=0; walk(root, ()=>c++); return c; }
function xpathEN(n){ return '/'+(n._pathEN||'') }
function expandAllRecursive(n){
  const ids=[]; walk(n, x=>{ if((x.children||[]).length || x._filteredCollapse) ids.push(x._id); });
  ids.forEach(id=> state.expanded.add(id));
}
function refreshStatsFromRepo(repo, root){ }
function showProgress(on){ els.progressWrap.style.display= on ? 'block':'none'; }
function downloadBlob(name, blob){
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=name; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}
function saveState(){
  localStorage.setItem(LS_VIEW, JSON.stringify(state.view));
  localStorage.setItem(LS_LEVEL, state.expandLevel);
  localStorage.setItem(LS_EXP, JSON.stringify(Array.from(state.expanded)));
}
function saveFiltersToLS(){
  localStorage.setItem(LS_FILTER_SERVICE, JSON.stringify(state.filtersService));
  localStorage.setItem(LS_FILTER_TYPICAL, JSON.stringify(state.filtersTypical));
  localStorage.setItem(LS_FILTER_TYPICAL_ONCE, JSON.stringify(state.filtersTypicalOnce));
}
function loadJSON(k, d){ try{ const v=localStorage.getItem(k); return v? JSON.parse(v): d; }catch(_){ return d; } }
function escapeHtml(s){ return String(s??'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

function exportBaseName(){
  let cand=null;
  if(state?.modelRoot){
    walk(state.modelRoot, n=>{
      if(!cand && /^atiso$/i.test(n.nameEN||'')) cand=n;
    });
  }
  if(cand?.nameRU) return normNameRu(cand.nameRU);
  if(state?.modelRoot?.nameRU) return normNameRu(state.modelRoot.nameRU);
  return 'Документ';
}
function normNameRu(s){
  return String(s||'Документ').trim()
    .replace(/[«»"<>]/g,'')
    .replace(/[.:]/g,'-')
    .replace(/\s+/g,' ')
    .replace(/ /g,'-')
    .slice(0,120);
}
function ts_hyphen(){
  const d=new Date(), p=n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}-${p(d.getHours())}-${p(d.getMinutes())}-${p(d.getSeconds())}`;
}

/* Сохранение позиции прокрутки при ререндере */
function withPreservedScroll(fn, focusId){
  const top = els.treeWrap.scrollTop;
  const focusRow = focusId ? els.tree.querySelector(`.row[data-id="${CSS.escape(focusId)}"]`) : null;
  const focusOffset = focusRow ? (focusRow.getBoundingClientRect().top - els.treeWrap.getBoundingClientRect().top) : null;

  suppressFocusScroll = true;
  try{ fn(); } finally{
    suppressFocusScroll = false;
    if(focusOffset!=null){
      const newRow = els.tree.querySelector(`.row[data-id="${CSS.escape(focusId)}"]`);
      if(newRow){
        const newOffset = newRow.getBoundingClientRect().top - els.treeWrap.getBoundingClientRect().top;
        els.treeWrap.scrollTop = top + (newOffset - focusOffset);
        $$('#tree .row').forEach(r=>r.setAttribute('aria-selected','false'));
        newRow.setAttribute('aria-selected','true');
        const rows=Array.from(els.tree.querySelectorAll('.row'));
        state.focusedIndex = Math.max(0, rows.indexOf(newRow));
      }else{
        els.treeWrap.scrollTop = top;
      }
    }else{
      els.treeWrap.scrollTop = top;
    }
  }
}

/* Кнопка сжатия дерева */
els.toggleCompact.addEventListener('click', ()=>{
  state.treeCompact = !state.treeCompact;
  localStorage.setItem(LS_TREE_COMPACT, String(state.treeCompact));
  applyTreeCompact();
});
function applyTreeCompact(){
  if(state.treeCompact){ els.treeWrap.classList.add('compact'); els.toggleCompact.textContent='Развернуть окно дерева'; }
  else { els.treeWrap.classList.remove('compact'); els.toggleCompact.textContent='Сжать окно дерева'; }
}

/* Переопределения фильтра */
function persistOverrides(){ localStorage.setItem(LS_OVERRIDES, JSON.stringify(Array.from(state.filterOverrides))); }

/* Вспомогательные */
function getByIdFull(id){
  if(!state.modelRoot || !id) return null;
  let found=null;
  walk(state.modelRoot, n=>{ if(!found && n._id===id) found=n; });
  return found;
}
function countDescendants(n){
  if(!n) return 0;
  let c=0;
  (n.children||[]).forEach(ch=>{
    c += 1 + countDescendants(ch);
  });
  return c;
}

/* Инициализация */
applyTreeCompact();
restoreViewCheckboxes();
rebuildAfterConfigChange();

/* Подстановка «Все» в селектор уровня при первом запуске */
elsAutoDepth.value = state.expandLevel || 'all';

function restoreViewCheckboxes(){
  document.querySelectorAll('[data-view]').forEach(x=>{
    const k=x.getAttribute('data-view'); x.checked = !!state.view[k];
  });
}
function rebuildAfterConfigChange(){
  ensureServiceFilterFlags();
  ensureTypicalFilterFlags();
  ensureTypicalOnceFilterFlags();
  if(state.modelRoot){
    reindexFlagsAll();
    annotateRequiredness(state.modelRoot);
    if(isSliceActive()){
      const anchor = sliceAnchorFromState();
      if(anchor){
        const expanded = ensureAnchorPathExpanded(anchor);
        if(expanded){ saveState(); }
      }
    }
  }
  renderModel();
}




// Экспорт текущего видимого дерева в CSV (UTF-8+BOM, sep=;, CRLF)
function exportCsvCurrentTree(){
  const model = filteredTree(); // учтены фильтры, сужение по ветке и текущее раскрытие
  if(!model){
    if (typeof showToast === 'function') showToast('Нет данных для экспорта');
    return;
  }
  const csvBody = generateCSV_FromView(model);     // тело CSV
  const content = 'sep=;\r\n' + csvBody;           // подсказка Excel о разделителе
  const bom = '\uFEFF';                            // UTF-8 BOM
  const blob = new Blob([bom, content], { type:'text/csv;charset=utf-8' });

  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'xsd_tree.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

// Генерация CSV с добавленным столбцом "Код"
function generateCSV_FromView(root){
  if(!root) return '';

  // Фиксированный порядок и состав колонок
const cols = [
  { key: 'num',        title: '№' },
  { key: 'ru',         title: 'Наименование', indent: true },
  { key: 'en',         title: 'Код' },
  { key: 'type',       title: 'Тип' },
  { key: 'req',        title: 'Обязательность' },
  { key: 'desc',       title: 'Описание' },
  { key: 'editCond',   title: 'Условия доступности редактирования' },
  { key: 'comment',    title: 'Комментарий' }
];

  const sep  = ';';
  const q    = s => `"${String(s||'').replace(/"/g,'""')}"`;
  const NBSP = '\u00A0';
  const PAD  = NBSP + NBSP;

  // Счётчики для иерархической нумерации
  const counters = [];
  function nextNumber(level){
    if (level === 0) return '0';           // верхний уровень всегда "0"
    const l = level - 1;                   // глубины ниже — обычная нумерация
    counters.length = l + 1;
    counters[l] = (counters[l] || 0) + 1;
    for (let i = l + 1; i < counters.length; i++) counters[i] = 0;
    return counters.slice(0, l + 1).join('.') + '.';
  }

  // Заголовок
  const header = cols.map(c => q(c.title)).join(sep);
  const lines = [header];

  // Обход видимого дерева
  walk(root, node => {
    const lvl = node.level ?? 0;
    const num = nextNumber(lvl);
    const indent = PAD.repeat(lvl);

    const ru   = node.nameRU || node.nameEN || '';
    const en   = node.nameEN || '';
    const type = node.type || '';
    const desc = (typeof node.description === 'string' && node.description) || '';
    const edit = node.editCond || '';
    const comm = node.comment || '';

const row = cols.map(c => {
  if (c.key === 'num')      return q(num);
  if (c.key === 'ru')       return q(indent + ru);
  if (c.key === 'en')       return q(en);
  if (c.key === 'type')     return q(type);
  if (c.key === 'req') {
    const reqTxt = node.req === 'required'   ? 'обяз.' :
                   node.req === 'conditional'? 'условно' : 'необяз.';
    return q(reqTxt);
  }
  if (c.key === 'desc')     return q(desc);
  if (c.key === 'editCond') return q(edit);
  if (c.key === 'comment')  return q(comm);
  return '""';
});

    lines.push(row.join(sep));
  });

  return lines.join('\r\n'); // CRLF для Excel
}




</script>
</body>
</html>
